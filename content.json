{"pages":[{"title":"关于我","text":"目前是一枚树莓人 👻👻👻👻👻👻 20岁秃头女大学生 不稳定的废话机器 希望自己 永远在路上 关于这里 这是一个使用Hexo框架创建 部署在GitHub上的个人博客 主题选用的是Anatolo 极简主义至上 非常喜欢这个风格 陆陆续续会加一些新功能和美化 严格意义来说并不算一个技术博 因为主要是我自己上传题解和笔记存档用的 大部分时候不喜欢写电子笔记 感觉还是要强迫自己敲点东西下来 联系方式 Emile：wxhxyyzm@163.com QQ: 2193318985","link":"/about/index.html"},{"title":"","text":"Ahh's Friends🌞 .links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card { width: 45%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card:nth-child(odd) { float: left; } .card:nth-child(even) { float: right; } .card:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card a { border:none; } .card .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card .card-header { font-style: italic; overflow: hidden; width: 100%; } .card .card-header a { font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; } .card .card-header a:hover { color: #d480aa; text-decoration: none; } .card .card-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: hidden; white-space: nowrap; } gigiboo's blog xmy在这里！","link":"/links/index.html"},{"title":"归档","text":"","link":"/archives/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"Alicenofear","text":"A sad me in a strang world 更一些other words 最近博客很久没有更新了 断断续续也有写题和补题 但是感觉没有及时整理和复盘 专业课的东西学的也有点吃力 旧的不会新的又来 额外的还有一些项目的东西要看 计算机好难学哦 acm好难打啊 我的大脑就像那种老旧配置低下的电子设备 时不时需要停下来什么都不干 冷却一段时间 但是赶路要紧 不能停下 整个人就好像被拖着走 发现自己写题的状态忽好忽坏 正式比赛的时候也会由于一点点状态的偏移 导致整场都很不OK 自己想了想 就是还不够熟练 太菜了吧 菜是原罪 写着Alice no fear 却找不到任何拯救自己的方式","link":"/2022/10/29/Alicenofear/"},{"title":"Hello World","text":"重生之我是拖拉机 想起来两月前要搭个博客放东西 结果算是被ddl催着完成的 行吧 那就多学多记 多练多写 多多思考 多多益善 hello-welcome-to-my-world","link":"/2022/09/04/hello-world/"},{"title":"holiday1","text":"擦擦落灰的博客 遣返了 提前开始放寒假，其实还没有总结一下惨痛的XCPC初体验，打得不好，但是好在还有一年。好像落了挺多题解没写的，算了，想的起来就更新一下吧，回看之前的题解已经看不懂我在写什么了（怎会如此）。依旧不放代码了，简写一下思路。 cf-Incinerate 题意：一群怪物有生命值h和力量p，可以对他们进行攻击，每次攻击，每个怪物都会掉k的生命值，但是接下来在剩下活着的怪物里会对k起到一个反作用，使得k减小（还活着怪物里面p的最小值），问是否能消灭所有的怪物。 求解：这题的关键就是要提前走一遍，先排序（因为依据题意一定是生命值小的先挂，所以可以排序），然后记录下区间内最小的p，每次k的减小就直接查询p就行。不难，但是感觉我好像还没有那个意识去用空间换时间，写法整体还是很暴力的。 cf-Another Array Problem 题意：一个数列，可以进行以下若干次操作：选下标i,j，使得在ai到aj之间的所有元素变成∣ai−aj∣|ai−aj|∣ai−aj∣，问最后数列中所有元素和的最大值。 求解：结论题。因为可以进行多次操作，并且第一次更新一个区间之后都变成一样的数了，第二次再进行操作就会全变成0了。所以可以利用来回的操作使得数字变成0，再和数列中的最大值进行操作，可以使得所有数字都变成最大值。但是n==2n==2n==2和n==3n==3n==3的时候没法来回处理。n==3n==3n==3的时候，如果最大值在中间，两边只有一个数，是没有办法进行上述操作的，所以就要枚举一下情况进行比较a[0]+a[1]+a[2],abs(a[0]−a[1])∗3,abs(a[1]−a[2])∗3,abs(a[0]−a[2])∗3,a[0]∗3,a[2]∗3{a[0]+a[1]+a[2],abs(a[0]-a[1])*3,abs(a[1]-a[2])*3,abs(a[0]-a[2])*3,a[0]*3,a[2]*3}a[0]+a[1]+a[2],abs(a[0]−a[1])∗3,abs(a[1]−a[2])∗3,abs(a[0]−a[2])∗3,a[0]∗3,a[2]∗3 C++20支持写max(a,b,c,d)max({a,b,c,d})max(a,b,c,d)来比较多个数的大小。","link":"/2022/12/20/holiday1/"},{"title":"Java-note01","text":"Java基础学习01-弱智写的笔记 概述 1.Java是面向对象的 2.Java是健壮的 3.Java是跨平台的 test.java -&gt; test.calss -&gt; linux/windows 一个编译好的.class文件可以在多个系统下运行 4.Java是解释性语言 解释性语言：js，php，java -不能被机器直接执行，需要解释器 编译性语言：C/C++ -可以被机器直接执行 配置 JVM Java核心运行机制 -JVM 1.JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在JDK中。 2.不同的平台有不同的虚拟机。 3.Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”。 JDK JDK=JRE+Java开发工具（javac,javadoc） JRE=JVM+Java核心类库 开发者需要JDK，使用者只需要JRE就可以运行 环境搭建 去官网下载JDK 然后改环境变量 步骤 1.增加JAVA_HOME的环境变量，指向路径 2.增加%JAVA_HOME%\\bin 第一个程序 1.新建hello.java文件 123456789//1.表示hello是一个公有类//2.public static void main(String[] args)是程序执行的入口//3.System.out.println 表示输出public class hello { //编写一个main方法 public static void main(String[] args) { System.out.println(&quot;Hello, World!&quot;); }} 2.编译源文件 从该路径下打开cmd 输入：javac hello.java 进行编译 如果报错注意是不是文件编码问题 GBK/UTF-8 3.运行 生成hello.class之后 输入：java hello.java 运行的本质就是将class文件（字节码文件）装载到对应的JAM中进行执行 细节说明 1.Java源文件拓展名：.java 基本组成部分是类 2.Java程序执行入口是main() 固定书写格式： 1public static void main(String[] args) {...} 3.大小写，分号，大括号等语言细节 4.编译后每一个类都有一个.class文件 5.如果源文件中有public类，那么文件名必须以此public类命名 6.一个源文件中最多只有一个public类，其他类个数不限，但可以将main写在非public中，然后指定非public类，这样入口方法就是非public的main方法 12345678910111213141516public class hello { //编写一个main方法 public static void main(String[] args) { System.out.println(&quot;Alice is studying java!&quot;); }}class tired{ public static void main(String[] args) { System.out.println(&quot;好困&quot;); }}class time{ public static void main(String[] args) { System.out.println(&quot;22:56&quot;); }} 命令行： 1234567D:\\ABOUT\\Java&gt;javac hello.javaD:\\ABOUT\\Java&gt;java tired好困D:\\ABOUT\\Java&gt;java time22:56 转义字符 \\t \\n \\ &quot; ’ \\r-回车 这块和其他语言也一样 不细写了","link":"/2023/01/02/note01/"},{"title":"Java-note02","text":"Java基础学习02-弱智写的笔记更新了 注释 单行注释：// 多行注释：/**/ 文档注释：注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档 1234/** * @author:Ahh * @version:xx */ 1javadoc -d directory -author -version comments.java 打开index.html就能看到相关信息 变量 变量先申明后使用 变量=变量名+值+数据类型 int double char String 数据类型 Java是强类型的一种语言 graph LR A[Java数据类型] --> B1(基本数据类型) --> C1(数值型) --> D1(整数 byte 1 short 2 int 4 long 8) C1 --> D2(浮点小数 float 4 double 8) B1 --> C2(字符型 char 2) B1 --> C3(布尔型 boolean 1) A --> B2(引用数据类型) B2 --> C4(类 class) B2 --> C5(接口 interface) B2 --> C6(数组) 新学了用markdown写流程图 记录一下 12graph LR; # 其中LR指的是方向 A --&gt; B # 不同的箭头表示 具体语法参考这篇 浮点数 java浮点型常量默认为double型，声明float型常量，后须加’f’/‘F’ 两种表达形式： 十进制 5.12 5.12.0f .512 科学计数法 5.12e2 5.12E-2 建议用精度高的double 小心运算后的小数 abs() Java API文档 graph LR A(JDK) --> B1(包1) --> C1(接口) B1 --> C2(类) --> D1(字段...) C2(类) --> D2(构造器) C2(类) --> D3(成员方法方法) B1 --> C3(异常) A --> B2(包2) A --> B3(包...) 学会查API包 基本数据类型转换 自动转换： 精度小的类型可以自动转换到精度大的类型 graph LR A1(char) --> B1(int) --> C1(long)-->D1(float)-->E1(double) S(byte)-->A2(short) --> B2(int) --> C2(long)-->D2(float)-->E2(double) 强制类型转换： 在前面加 (类型) 例： int n1=(int)12.9 要注意精度损失 String类型 123456789//正向int n1=100;String s1=n1+&quot;&quot;;//逆向String s2=&quot;123&quot;;int num1=Integer.parseInt(s2); System.out.println(s1+s2);//100123System.out.println(n1+num1);//223//其他数据类型同理 注意：注意数据格式 要不然会报异常 终止程序 输入语句 从控制台接受输入 导入包语句： 1234567891011121314import java.util.Scanner//表示把java.util下的Scanner类导入public class neww { public static void main(String[] args) { //Scanner类表示文本扫描器 //1.引入/导入 Scanner类所在的包 //2.创建Scanner对象，使用new Scanner mysc=new Scanner(System.in);//从键盘输入 System.out.println(&quot;input：&quot;); String s=mysc.nextLine(); int a = mysc.nextInt(); float b = mysc.nextFloat(); System.out.println(s+&quot; &quot;+a+&quot; &quot;+b); }} 写在最后 看的韩顺平的课…觉得自己学的太细了…零基础的学法了… 还是不应该这么学…从明天开始加速学一下…","link":"/2023/01/04/note02/"},{"title":"problem01","text":"记用hexo渲染Latex公式遇到的问题 一个问题 最近发现我hexo上公式好像没有渲染成功，换了各种引擎渲染依旧没有解决问题，看了一些教程，记录一下遇到的问题。 流程 网上大部分帖子是拿next主题讲的，所以一开始完全照做了。 1.卸载hexo-math和hexo-renderer-marked 2.安装hexo-renderer-pandoc 3.修改theme里面的config配置 4.本地安装pandoc 也遇到了一个报错pandoc exited with code 9: pandoc: Unknown extension: smart 查了一下是因为Anaconda\\Scripts目录下还有pandoc，而hexo默认使用Anaconda的pandoc，此pandoc版本过低。 更换了exe文件之后不报错了。 但是换了pandoc之后遇到的问题就是，$$并没有成功渲染，反而把所有的$渲染成了\\( 查了一些资料，其实一开始$和\\(都可以用作公式的渲染，所以我怀疑是中间的转义出了什么问题，但是检查了一下并没发现有问题。 后来发现可能是我使用的Analoto主题和Next还是不太一样，在询问了主题作者的情况下，发现模板并没有使用math，所以之前修改config的时候我也发现好像没有集成math模块，因此修改可能是无效的，也有可能我中间哪一步做错了，导致出现了bug。 后来尝试在主题中手动添加js安装mathjax，好像并没有什么效果，也可能是那个时候没有卸载掉前面安装的包，导致渲染结果的一直不正确。 最后参考了一个博主写的方法 替换默认的渲染器，这块还是一样的，不过使用的包不一样了。 12npm un hexo-renderer-marked --savenpm i @upupming/hexo-renderer-markdown-it-plus --save 然后引入katex的样式文件，然后需要引入katex的样式文件，这里要注意官方的文档里用的还是0.9.0的老版本同样不支持换行，所以需要改成0.10.2的版本，这里使用字节的cdn，将其放入主题文件夹下的layout\\_partials\\head中。 1&lt;link href=&quot;https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css&quot; rel=&quot;stylesheet&quot;&gt; 最后记得要把前面安装的没成功的东西卸载了，要不然渲染的还是错的。 测试 落泪了T T 1(ϕ5−ϕ)e25π≡1+e−2π1+e−4π1+e−6π1+e−8π1+⋯\\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} \\equiv 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots} } } } (ϕ5​​−ϕ)e52​π1​≡1+1+1+1+1+⋯e−8π​e−6π​e−4π​e−2π​ E(x)=∑i=1nXinE(x)=\\frac{\\sum_{i=1}^{n}{X_{i}}}{n} E(x)=n∑i=1n​Xi​​ lim1→+∞P(∣1n∑inXi−μ∣&lt;ϵ)=1,i=1,...,nlim_{1\\to+\\infty}P(|\\frac{1}{n}\\sum_i^nX_i-\\mu|&lt;\\epsilon)=1, i=1,...,n lim1→+∞​P(∣n1​i∑n​Xi​−μ∣&lt;ϵ)=1,i=1,...,n 总结 其实我的博客里面有很多东西都没搭好，一方面是因为我懒，另一方面是我选Anatolo是因为它很简洁好看，但是一些功能可能就没有别的主题集成的那么好了，之后再慢慢加吧。感觉目前为止遇到的一些bug都可以通过查别人的技术帖解决的，不过还是要就帖论帖，直接无脑搬用大概率还是会出bug。","link":"/2023/01/04/problem01/"},{"title":"week5","text":"达成三个单周坚持写博客成就（555因为双周都没写orz） 进度依然慢… cf-Card Game 题意：博弈问题 给个n即n张牌（由1到n）每个人分n/2张 从Alex开始出牌 后手一定要比先手出的牌大 接u着Boris出 到谁出不了了就输了 求Alex赢、Boris赢和平局的分牌方式 求解：从最大的四张开始分 A先手 所以A赢就有两种 要么最大的在A 如果最大在B 那剩下的n-1和n-2必须在A n-3在A A赢 n-3不在 这四张牌平局 因而递归下去 由此可得f[n]=C(n/2-1,n-1)+C(2/n-3,n-4)+f[n-4]的递归公式 四张四张求解即可 写这题的时候思维很凝固的感觉 感觉还是要从NP开始想 觉得我的思考很没有条理性 还要注意一点 有取模和减法一起出现的时候 为了防止出现负数 要+MOD再%MOD 贴一个求组合数的板子(n比较小的情况) 123456789101112131415void C(){ c[0][0]=1; for(int i=0;i&lt;=70;i++) { for(int j=0;j&lt;=70;j++) { if(j==0||j==i) c[i][j]=1; else { c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod; } } }} cf-Reset K Edges 题意：给n个结点 以及他们的深度（1的深度是0）还可以进行k次操作 一次操作：删掉一条边 将剩下的连到1的下面去 问最多经过k操作后的最小的树的深度 求解：二分+贪心 从下向上遍历 到了高度为mid-1的那一层 如果是根节点 那么不用动 但如果不是 就把这棵子树接到1上 记录进行的操作次数与k对比 注意为了做到无后效性 要从下向上遍历 cf-1250J 题意：有一群人 要站队 给个n 给个k n表示有n个不同的身高 (全部的身高从1-n) k表示要站几排 然后会依次给出每个身高下有多少个人 站队要求：一排里面两人身高最多相差1cm 求最后的方针里最多有多少个人 求解：求最大最小值的问题自然想到二分 这题是一个二分+一点贪心 总体框架没什么问题 在站队的贪心上出了点问题 应该是从小到大依次看这个身高能组成多少队列 然后从后一个身高里取一部分人恰好凑成新的一列 这样的贪心才是最优的（搞不懂我怎么想的 就不写错误思路了） arc146-B Plus and AND 题意：n m k n个数 能给他们加m个1 问选k个数 进行与运算(e.g 011 AND 101=001)的最大值 求解：位运算的问题 从高位到低位贪心 如果m能够使得 k个数字这一位都为1 就消耗掉 如果不能 就继续向下贪心（因为只要有1个0 与运算后就都为0了）从31跑到0 一位一位判断 其实感觉这题思路倒是很好理解 就是代码好难写哦(我太菜了) 贴个代码吧 12345678910111213141516171819202122232425for(int i=31;i&gt;=0;i--)//从高位到低位贪心 { for(int j=0;j&lt;n;j++) { b[j]=c[j]; if((a[j]&gt;&gt;i)&amp;1) continue; else b[j]+=(1ll&lt;&lt;i)-(a[j]%(1ll&lt;&lt;i)); } sort(b,b+n); ll sum=0; for(int j=0;j&lt;k;j++) sum+=b[j]; if(sum&lt;=m) { ans|=(1ll&lt;&lt;i); for(int j=0;j&lt;n;j++) { if(a[j]&gt;&gt;i&amp;1) continue; else { c[j]+=(1ll&lt;&lt;i)-(a[j]%(1ll&lt;&lt;i)); a[j]=1ll&lt;&lt;i; } } } } zls说位运算就要么从高位到低位想 要么从低位到高位想 牛客-跳石头 题意：给L N M 分别表示起点到终点的距离 起点和终点之间的岩石数 以及组委会至多移走的岩石数 求最短跳跃距离的最大值 求解：经典二分 通过mid看需要移走几块石头 贴个check代码 12345678910111213int cnt=0;int last=0;for(int j=0;j&lt;=n;j++){ if(x[j]-last&lt;w) cnt++; else { last=x[j]; }}if (cnt&lt;=m) return true;else return false; 牛客-数字组合 题意：给四个数组 问每个数组取一个数字 四个数字和为0 有多少种取法 求解：一个时间复杂度上的优化 先两两加一下组成两个新的数组 然后二分查找一下 牛客-[CQOI2010]扑克牌 题意：有n种牌 每种牌张数不一样 还有m张joker n张不同的牌可以凑成一副牌 但是每副牌里不能出现相同的牌（即joker最多可以代替一张普通牌）问最多多少副牌 求解：还是二分 判断要补多少张joker（注意不能超过mid） 注意开long long 1234567int s=0;for(int i=0;i&lt;n;i++){ s+=max(mid-a[i],(long long)0); } if(m&gt;=s&amp;&amp;mid&gt;=s) return true; else return false;false; 牛客-K-th Number 题意：A数组有n个数 给了个k 将所有大于等于k的区间中的第k大的数放入B数组中 然后问B中第m大的数是哪个 求解：这题很难想到是二分（如果没出现在题单里我肯定想不到）找出所有区间中包含大于等于k个大于等于mid的区间的数量 check函数不太好写 看到很牛的代码 用数组s去记录从1开始大于等于mid的数字数量 然后从第k个数开始遍历 如果（l-i）区间满足条件 那么l之前的更长的区间必定满足条件 所以sum+=l即是目前为止满足条件的区间数 整个思维的转换很有意思 123456789101112int sum=0;for(int i=1;i&lt;=n;i++){ if(a[i]&gt;=mid) s[i]=s[i-1]+1; else s[i]=s[i-1];}int l=0;for(int i=k;i&lt;=n;i++){ while(s[i]-s[l]&gt;=k) l++; sum+=l;} 总结 先写这么多 感觉最近整个思维出现很紊乱的状态 下周开始复习一些基础的东西+过一遍贪心","link":"/2022/10/03/week5/"},{"title":"week2-3","text":"因为一些原因上周落了一些orz 这两周继续递归分治+一点二分 顺便改进了一下写博客的方法 [NOIP2001]求先序排列 题意：已知二叉树的中序和后序排列，求它的先序排列； 求解：二叉树的基本题，首先概念：先序：根-左-右；中序：左-根-右；后序：左-右-根 通过后序的最后一个位置确定根 通过这个根 在中序中找到根的位置 左边是左子树 右边是右子树；然后用递归的方式 事实上中序和后序表达的是同一颗子树 所以可以用长度求出第四个端点； 1234deal(l1,r1,l2,r2);//1中序 2后序deal(l1,pos-1,l2,l2+pos-1-l1);//pos是在中序里找到的根的位置deal(pos+1,r1,l2-l1+pos,r2-1); [NOIP2004]FBI树 题意：全0：B；全1：I；有1有0：F；给定一个长度为2的n次方的“01”串，求其FBI树的后序遍历（左右根） 求解：递归做法 多点判断+后序输出 按左右根的顺序 如果到叶节点就直接判断输出 华华教月月做数学 题意：就是求 A^B mod P 求解：基础的快排板子 有一个大数的问题 （可以用python解决 __int128也可以过）或者可以将快速幂中的乘法拆成加法求余 快速幂的思想就是倍增思想 把幂拆掉求余 贴个板子 1234567891011ll quickm(ll a,ll b,ll p){ tmp=a,ans=1; while(b) { if(b&amp;1) ans=ans*tmp%p; tmp=tmp*tmp%p; b&gt;&gt;=1; } return ans;} P2880 [USACO07JAN] Balanced Lineup G 题意：给个为n的数列 给q次询问 每次问a,b之间最大值和最小值之间的差值 求解：线段树 写两棵树 一棵树存最大的 一棵树存最小的 然后相减一下 P1115 最大子段和 题意：如题 求解：两种想法 一是分治：①求左边的最大字段和②求右边的最大字段和③求左边那段包含最右边点的最大字段和+右边那段包含最左边点的最大字段和 三者取最大 二是贪心：求前缀和 一旦前缀和小于0 就清零 写二的时候卡了一次 没有把第一个数存下来当sum 感觉这个贪心想的没有那么直观（我太菜了） P1257 平面上的最接近点对 题意：如题 求解：还是分治：取个中轴线 ①求左边平面最接近点 ②求右边平面最接近点 ③分在两边平面的点 但可以用前两个求出来的最小值来约束y轴范围 排个序 这样就是从有限的点中求出最短距离； P1613 跑路 题意：给n个点 m条边 一条边代表一千米 每秒可以跑2^k（k是任意自然数）千米 要求从1到n的最小时间 求解：这题感觉还是很有意思的 因为n&lt;=50 所以可以很暴力 用倍增的思想预处理一下数据 i到t再到j 如果i到j有2^k-1千米的路 j到t又有2^k-1千米的路 那么i到j就有2^k的路 可以一秒到达 把dis改为1最后用Floyd法求最短路 疯狂写循环（ 123456789101112131415161718192021void bz(){ for(int k=1;k&lt;=64;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int t=1;t&lt;=n;t++) { if(b[i][j][k-1]&amp;&amp;b[j][t][k-1]) { b[i][t][k]=true; dis[i][t]=1; } }}void floyd(){ for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); } P2415 集合求和 题意：输入一个集合的所有元素 求所有子集的元素之和 求解：数学问题 首先会有2^n个子集 一半有这个数 另一半没有这个数 所以总共出现了2^（n-1）次 算一下就可以了 P3197 [HNOI2008]越狱 题意：有n个屋子 m种宗教 相邻的屋子里的人如果是同一种宗教就会越狱 问有多少种可能 答案对100003 取模 求解：还是数学问题 公式是mn-(m-1)(n-1) 还是一个快速幂的题目 但是！wa了好几次 后来发现是最后因为是一个减法 有可能存在负数的情况 所以要+p再%p P2249 【深基13.例1】查找 题意：二分查找 求解：用的lower_bound（第一个≥x的位置）和upper_bound（第一个＞x的位置）自带函数做的 自己写的话很容易出现边界和卡在循环里面的问题 每次写的时候还是要注意一下 P1102 A-B 数对 题意：给N个数和C 求数列中满足A-B的数对个数 求解：写了个双循环然后用二分查找的函数直接写的 十分暴力简单的做法（ P1873 [COCI 2011/2012 #5] EKO / 砍树 题意：N个木材 需要总长度M 定一个H使得能够砍到M米木材 为了怕浪费 求最小的H 求解：二分的运用 就写个check函数判断一下 如果能砍到M就改r 否则就改l P1678 烦恼的高考志愿 题意：给出m个分数线 以及n个同学的估分 要求帮每个估分找出最合理的分数线 两者相差为不满意度 求不满意度最小值 求解：还是用的二分函数 给分数线排个序 用每个人的估分去找相近的分数线 然后前后都算一下 取一个min值 P2440 木材加工 题意：把n根原木切割成 k 段长度均为 l 的小段木头 求l的最大值 求解：依然是二分的运用 写个check能切成k段就缩小一点l 反之放大 写起来很简单 总结 进度还是挺慢 其实很多东西都相当于复习了 但是！完全没有印象… 所以改进了一下写题解的方式 看起来轻松些 便于自己复习 也不贴代码了 有空还可以自己再码一遍 要不然学过和没学一样orz 做的题都不算难 重建一下信心（）下周继续二分","link":"/2022/09/20/week3/"},{"title":"康复训练1","text":"9.5-9.8 这周主要是复习一下…发现很多东西都不记得了orz 递归、分治 主要写了点板子题目 典型的逆序对 归并排序代码改的 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int a[500005],b[500005];long long n,cnt;void add(int l,int r){ int mid=(l+r)/2; int p=l,q=mid+1; for(int i=l;i&lt;=r;i++) { if((q&gt;r)||(p&lt;=mid&amp;&amp;a[p]&lt;=a[q])) b[i]=a[p++]; else { cnt+=mid-p+1;//多这一行代码 b[i]=a[q++]; } } for(int i=l;i&lt;=r;i++) a[i]=b[i];}void merg(int l,int r){ if(l==r) return; int mid=(l+r)/2; merg(l,mid); merg(mid+1,r); add(l,r);}int main(){ cin&gt;&gt;n; for(int i=0;i&lt;n;i++) { cin&gt;&gt;a[i]; } merg(0,n-1); cout&lt;&lt;cnt&lt;&lt;endl; } 其实好像感觉之前也写过…sort过的 记一个快读板子（卡了好几次在这） 1234567891011121314inline int read(){ int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9'){ if (ch == '-') f = -1; ch = getchar(); } while(ch &gt;= '0' &amp;&amp; ch &lt;= '9'){ x = (x&lt;&lt;1) + (x&lt;&lt;3) + (ch^48); ch = getchar(); } return x * f;} 兔子的逆序对 大量读入需要快读板子 因为反转操作实际是将逆序对变成正序对 正序对变成逆序对 因为每交换一次就改变一次逆序对对数的奇偶性 所以只关注交换的次数就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;iostream&gt;#define int long longusing namespace std;const int N=100005;int a[N],b[N];long long n,cnt,cnt1,cnt2,t,f;inline int read(){ char c=getchar();int f=1; int x=0; while (c&lt;'0'||c&gt;'9') { if (c=='-') f=-1; c=getchar(); } while (c&gt;='0'&amp;&amp;c&lt;='9') { x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48); c=getchar(); } return x*f;}void add(int l,int r){ int mid=(l+r)/2; int p=l,q=mid+1; for(int i=l;i&lt;=r;i++) { if((q&gt;r)||(p&lt;=mid&amp;&amp;a[p]&lt;=a[q])) b[i]=a[p++]; else { cnt+=mid-p+1; b[i]=a[q++]; } } for(int i=l;i&lt;=r;i++) a[i]=b[i];}void merg(int l,int r){ if(l==r) return; int mid=(l+r)/2; merg(l,mid); merg(mid+1,r); add(l,r);}signed main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { a[i]=read(); } scanf(&quot;%lld&quot;,&amp;t); merg(1,n); if(cnt%2) f=1; else f=0; while(t--) { int a,b; scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b); int d=(b-a)*(b-a+1)/2; if(d%2) { f^=1; } if(f) printf(&quot;dislike\\n&quot;); else printf(&quot;like\\n&quot;); } } 快排板子 求第k大的数字 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int a[100];int n;void quick_sort(int l,int r){ int mid=(l+r)/2; int i=l,j=r; int x=a[mid];//store it while(a[i]&lt;x) i++; while(a[j]&gt;x) j--; while(i&lt;=j) { swap(a[i],a[j]); i++;j--; } if(l&lt;j) quick_sort(l,j);//如果是求第k大的数 改个这里 抛弃另一半 if(i&lt;r) quick_sort(i,r);}int main(){ cin&gt;&gt;n; for(int i=0;i&lt;n;i++) { cin&gt;&gt;a[i]; } quick_sort(0,n-1); for(int i=0;i&lt;n;i++) { cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; }} 一些递归的水题 更相减损术 实际上就是欧拉公式 遥远的数论记忆、、、 gcd(a,b)=gcd(a,a%b)/gcd(a,a-b) 证明很简单 12345int gcd(int a,int b){ if(b==0) return a; return gcd(b,a%b);} 汉诺塔问题 嗯…感觉也是个规律问题 求解的时候牵涉了一点点高中数列的求通项 由A-&gt;C: (1)以C盘为中介，从A杆将1至n-1号盘移至B杆； (2)将A杆中剩下的第n号盘移至C杆； (3)以A杆为中介；从B杆将1至n-1号盘移至C杆。 f(n)=2*f(n-1)+1; 12345678void hanoi(int n, char a, char b, char c) { if (n == 0) return; hanoi(n - 1, a, c, b);//将n-1个盘子由A经过C移动到B printf (&quot;step %d: move %d from %c-&gt;%c\\n&quot;, cnt++, n, a, c); hanoi(n - 1, b, a, c);//剩下的n-1盘子，由B经过A移动到C} 有的题目会有一些附加条件 要自己重新算一下 感觉主要是求通项的问题 写代码直接写结论就可以了 other 还有一些很简单的递归就不写了 一直觉得递归很难理解、、、说是将递归当成一把钥匙开一把锁然后一直到最里面那把钥匙（） 主要是思想问题 很需要理解（笨人落泪） 补了几道cf 我有罪 我没及时补题 想起来有一些比赛的时候没写出来的C Color the Picture 一个贪心问题 就是要保证颜色一定能涂相连的两行/两行以上 不能出现只有一行剩下的情况 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int t,n,m,k;int a[100005];bool solve(int m,int n,int k){ int ans=0; for(int i=0;i&lt;k;i++) { if(a[i]/n&gt;=2) { if((m-(ans+a[i]/n))==1) { if(a[i]/n&gt;2) ans+=(a[i]/n-1); } else ans+=a[i]/n; } } if(ans&gt;=m) return true; return false;}signed main(){ cin&gt;&gt;t; while(t--) { cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=0;i&lt;k;i++) { cin&gt;&gt;a[i]; } sort(a,a+k); if(solve(n,m,k)||solve(m,n,k)) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; }}l; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; }} o 还wa了一发在long long上 Doremy’s IQ 觉得逆向思维的话更好理解 也更好写代码一些 也是贪心 就尽量让使q变小的排在后面 逆序遍历 从0开始 后面的都要 直到q等于题目给的q 不满足条件的就不要了 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#define int long longusing namespace std;const int N=100005;int t,n,q;int a[N];int b[N];signed main(){ cin&gt;&gt;t; while(t--) { cin&gt;&gt;n&gt;&gt;q; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; int cnt=0; for(int i=n-1;i&gt;=0;i--) { if(cnt&lt;q) { if(a[i]&gt;cnt) { cnt++; } b[i]=1; } else { if(q&gt;=a[i]) b[i]=1; else b[i]=0; } } for(int i=0;i&lt;n;i++) cout&lt;&lt;b[i]; cout&lt;&lt;endl; }} Digital Logarithm 这题比赛的时候debug半小时、、无语住了 代码基本功太差了、、 思路大概就是先去重 然后求位数 再统计一下各个位数 然后求差值 去重不会写 sls教的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;using namespace std;int t,x,n;const int N=200005;int a[N],b[N];int qws(int x){ int cnt=0; while(x) { x=x/10; cnt++; } return cnt;}void qc(){ int i=1;int j=1; while(i&lt;=n&amp;&amp;j&lt;=n) { if(a[i]&lt;b[j]) i++; else if(a[i]&gt;b[j]) j++; else { a[i]=0;b[j]=0;i++;j++; } }}signed main(){ cin&gt;&gt;t; while(t--) { cin&gt;&gt;n; int b1[15],b2[15];memset(b1,0,sizeof(b1));memset(b2,0,sizeof(b2)); int ccnt=0; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;=n;i++) cin&gt;&gt;b[i]; sort(a+1,a+n+1); sort(b+1,b+1+n); qc(); for(int i=1;i&lt;=n;i++) { if(a[i]&gt;9) { a[i]=qws(a[i]); ccnt++; } if(b[i]&gt;9) { b[i]=qws(b[i]); ccnt++; } } for(int i=1;i&lt;=n;i++) { b1[a[i]]++; b2[b[i]]++; } for(int i=2;i&lt;=9;i++) { ccnt+=abs(b1[i]-b2[i]); } cout&lt;&lt;ccnt&lt;&lt;endl; }} 写在最后 嗯…效率比预计得低很多 下周继续做递归分治 板子写的还不够熟T T","link":"/2022/09/10/%E5%BA%B7%E5%A4%8D%E8%AE%AD%E7%BB%831/"},{"title":"数学建模笔记-蒙特卡罗模拟","text":"这部分主要得会写代码 引例 蒲丰投针问题： 18世纪，法国数学家布丰提出的“投针问题”，记载于布丰1777年出版的著作中：“在平面上画有一组间距为a的平行线，将一根长度为l（l≤a）的针任意掷在这个平面上，求此针与平行线中任一条相交的概率。” 1） 取一张白纸，在上面画上许多条间距为a的平行线。 2） 取一根长度为l（l≤a） 的针，随机地向画有平行直线的纸上掷n次，观察针与直线相交的次数，记为m。 3）计算针与直线相交的概率。 布丰本人证明了，这个概率是：P=2lπaP=\\tfrac{2l}{πa}P=πa2l​(其中π为圆周率） 证明：当x≤l2sinϕ,0≤x≤a2,0≤ϕ≤πx\\leq \\tfrac{l}{2} sin\\phi,0\\le x\\le \\tfrac{a}{2},0\\le \\phi \\le \\pix≤2l​sinϕ,0≤x≤2a​,0≤ϕ≤π时，才符合题意，其中x为直线的中点到最近的平行线的距离 ϕ\\phiϕ为直线与最近平行线的夹角，由几何概率的定义可以求得P，由于大数定理，当n足够大的时候，频率趋近于概率，以此来得到π\\piπ的值。 用matlab模拟： 123456789101112131415161718192021% rand(m,n)可以生成一个m行n列的矩阵，每个元素值在[0,1]之间% rand(n)只有一个值就是n*n的方阵% a+rand(m,n)*(b-a) 可以生成一个m行n列的矩阵，每个元素值在[a,b]之间 等价于unifrnd(a,b,m,n)l = 0.520; % 针的长度（任意给的）a = 1.314; % 平行线的宽度(大于针的长度l即可)n = 1000000; % 做n次投针试验，n越大求出来的pi越准确m = 0; % 记录针与平行线相交的次数x = rand(1, n) * a / 2 ; % 在[0, a/2]内服从均匀分布随机产生n个数， x中每一个元素表示针的中点和最近的一条平行线的距离phi = rand(1, n) * pi; % 在[0, pi]内服从均匀分布随机产生n个数，phi中的每一个元素表示针和最近的一条平行线的夹角% axis([0,pi, 0,a/2]); box on; % 画一个坐标轴的框架，x轴位于0-pi，y轴位于0-a/2， 并打开图形的边框for i=1:n % 开始循环，依次看每根针是否和直线相交 if x(i) &lt;= l / 2 * sin(phi (i)) % 如果针和平行线相交 m = m + 1; % 那么m就要加1% plot(phi(i), x(i), 'r.') % 模仿书上的那个图，横坐标为phi，纵坐标为x , 用红色的小点进行标记% hold on % 在原来的图形上继续绘制 endendp = m / n; % 针和平行线相交出现的频率mypi = (2 * l) / (a * p); % 我们根据公式计算得到的pidisp(['蒙特卡罗方法得到pi为：', num2str(mypi)]) 可以重复多次求平均值 概述 定义 蒙特卡罗⽅法⼜称统计模拟法，是⼀种随机模拟⽅法，以概率和统计理论⽅法为基础的⼀种计算⽅法，是使⽤随机数（或更常⻅的伪随机数）来解决很多计算问题的⽅法。将所求解的问题同⼀定的概率模型相联系，⽤电⼦计算机实现统计模拟或抽样，以获得问题的近似解。为象征性地表明这⼀⽅法的概率统计特征，故借⽤赌城蒙特卡罗命名。 原理 大数定理 当样本容量足够大时，事件的发生频率即为其概率。 蒙特卡罗模拟不是一个通用的代码，而是一种思想。 问题 问题一：三门问题 问题的提出：你参加一档节目，节目有ABC三扇门，其中一扇门后面有汽车，另外两扇门后是空的。假设你选择了B门，这时C门被打开了，C门后面什么都没有，那么要不要改选A门？ 结论：如果换了A得奖的概率是三分之二，不换门概率是三分之一。（好神奇啊） 蒙特卡罗模拟： 在赢的条件下，没考虑输的，条件概率： 12345678910111213141516% randi([a,b],m,n)函数可在指定区间[a,b]内随机取出大小为m*n的整数矩阵n = 100000; % n代表蒙特卡罗模拟重复次数a = 0; % a表示不改变主意时能赢得汽车的次数b = 0; % b表示改变主意时能赢得汽车的次数for i= 1 : n % 开始模拟n次 x = randi([1,3]); % 随机生成一个1-3之间的整数x表示汽车出现在第x扇门后 y = randi([1,3]); % 随机生成一个1-3之间的整数y表示自己选的门 % 下面分为两种情况讨论：x=y和x~=y if x == y % 如果x和y相同，那么我们只有不改变主意时才能赢 a = a + 1; b = b + 0; else % x ~= y ，如果x和y不同，那么我们只有改变主意时才能赢 a = a + 0; b = b +1; endenddisp(['蒙特卡罗方法得到的不改变主意时的获奖概率为：', num2str(a/n)]);disp(['蒙特卡罗方法得到的改变主意时的获奖概率为：', num2str(b/n)]); 有输的情况，无条件概率： 1234567891011121314151617181920212223242526n = 100000; % n代表蒙特卡罗模拟重复次数a = 0; % a表示不改变主意时能赢得汽车的次数b = 0; % b表示改变主意时能赢得汽车的次数c = 0; % c表示没有获奖的次数for i= 1 : n % 开始模拟n次 x = randi([1,3]); % 随机生成一个1-3之间的整数x表示汽车出现在第x扇门后 y = randi([1,3]); % 随机生成一个1-3之间的整数y表示自己选的门 change = randi([0, 1]); % change =0 不改变主意，change = 1 改变主意 % 下面分为两种情况讨论：x=y和x~=y if x == y % 如果x和y相同，那么我们只有不改变主意时才能赢 if change == 0 % 不改变主意 a = a + 1; else % 改变了主意 c= c+1; end else % x ~= y ，如果x和y不同，那么我们只有改变主意时才能赢 if change == 0 % 不改变主意 c = c + 1; else % 改变了主意 b= b + 1; end endenddisp(['蒙特卡罗方法得到的不改变主意时的获奖概率为：', num2str(a/n)]);disp(['蒙特卡罗方法得到的改变主意时的获奖概率为：', num2str(b/n)]);disp(['蒙特卡罗方法得到的没有获奖的概率为：', num2str(c/n)]); 问题二：模拟排队问题 问题的提出：假设某银⾏⼯作时间只有⼀个服务窗⼝，⼯作⼈员只能逐个的接待顾客。当来的顾客较多时，⼀部分顾客就需要排队等待。 有以下假设： 顾客到来的间隔时间服从参数为0.1的指数分布 每个顾客的服务时间服从均值为10，⽅差为4的正态分布(单位为分钟，若服务时间⼩于1分钟，则按1分钟计算) 排队按先到先服务的规则，且不限制队伍的⻓度，每天⼯作时⻓为8⼩时。 试回答下⾯的问题： 模拟⼀个⼯作⽇，在这个⼯作⽇共接待了多少客户，客户平均等待的时间为多少? 模拟100个⼯作⽇，计算出平均每⽇接待客户的个数以及每⽇客户的平均等待时⻓。 建立模型： x(i)表示第i-1个客户和第i个客户到达的间隔时间，服从参数为0.1的指数分布 y(i)表示第i个客户的服务持续时间，服从均值为10方差为4(标准差为2)的正态分布 (若小于1则按1计算) c(i)表示第i个客户的到达时间，那么c(i) = c(i-1) + x(i)，初始值c0=0 b(i)表示第i个客户开始服务的时间 e(i)表示第i个客户结束服务的时间，初始值e0=0 第i个客户结束服务的时间 = 第i个客户开始服务的时间 + 第i个客户的服务持续时间 即：e(i) = b(i) + y(i） 第i个客户开始服务的时间取决于该客户的到达时间和上一个客户结束服务的时间 即：b(i) = max(c(i),e(i-1))，初始值b1=c1; 第i个客户等待的时间 = 第i个客户开始服务的时间 - 第i个客户到达银行的时间 即：wait(i) = b(i) - c(i) w表示所有客户等待时间的总和 假设一天内银行最终服务了n个顾客，那么客户的平均等待时间t = w/n 预备知识 12345678910% normrnd(MU,SIGMA):生成一个服从正态分布(MU参数代表均值,SIGMA参数代表标准差,方差开根号是标准差)的随机数normrnd(10,2) % 均值为10 标准差为2（方差为4）的正态分布随机数% exprnd(M)表示生成一个均值为M的指数分布随机数(其对应的参数为1/M)exprnd(5) % 均值为5的指数分布随机数（对应的参数为0.2）% mean函数是用来求解均值的函数（第一期视频第五讲）mean([1,2,3])% tic函数和toc函数可以用来返回代码运行的时间，例如我们要计算一段代码的运行时间，就可以在这段代码前加上tic，在这段代码后加上toc (我的微信公众号&quot;数学建模学习交流&quot;中有一篇推送《为什么要对代码初始化》中使用过这对函数)tica = 2^100toc 问题1的代码 12345678910111213141516171819202122232425tic %计算tic和toc中间部分的代码的运行时间i = 1; % i表示第i个客户，最开始取i=1w = 0; % w用来表示所有客户等待的总时间，初始化为0e0 = 0; c0 = 0; % 初始化e0和c0为0x(1) = exprnd(10); % 第0个客户(假想的)和第1个客户到达的时间间隔c(1) = c0 + x(1); % 第1个客户到达的时间b(1) = c(1); % 第1个客户的开始服务的时间while b(i) &lt;= 480 % 开始设置循环，只要第i个顾客开始服务的时间(时刻)小于480，就可以对其服务（银行每天工作8小时，折换为分钟就是480分钟） y(i) = normrnd(10,2); % 第i个客户的服务持续时间，服从均值为10方差为4(标准差为2)的正态分布 if y(i) &lt; 1 % 根据题目的意思：若服务持续时间不足一分钟，则按照一分钟计算 y(i) = 1; end e(i) = b(i) + y(i); % 第i个客户结束服务的时间 = 第i个客户开始服务的时间 + 第i个客户的服务持续时间 wait(i) = b(i) - c(i); % 第i个客户等待的时间 = 第i个客户开始服务的时间 - 第i个客户到达银行的时间 w = w + wait(i); % 更新所有客户等待的总时间 i = i + 1; % 增加一名新的客户 x(i) = exprnd(10); % 这位新客户和上一个客户到达的时间间隔 c(i) = c(i-1) + x(i); % 这位新客户到达银行的时间 = 上一个客户到达银行的时间 + 这位新客户和上一个客户到达的时间间隔 b(i) = max(c(i),e(i-1)); % 这个新客户开始服务的时间取决于其到达时间和上一个客户结束服务的时间endn = i-1; % n表示银行一天8小时一共服务的客户人数t = w/n; % 客户的平均等待时间disp(['银行一天8小时一共服务的客户人数为: ',num2str(n)])disp(['客户的平均等待时间为: ',num2str(t)])toc %计算tic和toc中间部分的代码的运行时间 问题2的代码 123456789101112131415161718192021222324252627282930tic %计算tic和toc中间部分的代码的运行时间day = 100; % 假设模拟100天n = zeros(day,1); % 初始化用来保存每日接待客户数结果的矩阵t = zeros(day,1); % 初始化用来保存每日客户平均等待时长的矩阵for k = 1:day i = 1; % i表示第i个客户，最开始取i=1 w = 0; % w用来表示所有客户等待的总时间，初始化为0 e0 = 0; c0 = 0; % 初始化e0和c0为0 x(1) = exprnd(10); % 第0个客户(假想的)和第1个客户到达的时间间隔 c(1) = c0 + x(1); % 第1个客户到达的时间 b(1) = c(1); % 第1个客户的开始服务的时间 while b(i) &lt;= 480 % 开始设置循环，只要第i个顾客开始服务的时间(时刻)小于480，就可以对其服务（银行每天工作8小时，折换为分钟就是480分钟） y(i) = normrnd(10,2); % 第i个客户的服务持续时间，服从均值为10方差为4(标准差为2)的正态分布 if y(i) &lt; 1 % 根据题目的意思：若服务持续时间不足一分钟，则按照一分钟计算 y(i) = 1; end e(i) = b(i) + y(i); % 第i个客户结束服务的时间 = 第i个客户开始服务的时间 + 第i个客户的服务持续时间 wait(i) = b(i) - c(i); % 第i个客户等待的时间 = 第i个客户开始服务的时间 - 第i个客户到达银行的时间 w = w + wait(i); % 更新所有客户等待的总时间 i = i + 1; % 增加一名新的客户 x(i) = exprnd(10); % 这位新客户和上一个客户到达的时间间隔 c(i) = c(i-1) + x(i); % 这位新客户到达银行的时间 = 上一个客户到达银行的时间 + 这位新客户和上一个客户到达的时间间隔 b(i) = max(c(i),e(i-1)); % 这个新客户开始服务的时间取决于其到达时间和上一个客户结束服务的时间 end n(k) = i-1; % n(k)表示银行第k天服务的客户人数 t(k) = w/n(k); % t(k)表示该银行第k天客户的平均等待时间enddisp([num2str(day),'个工作日中，银行每日平均服务的客户人数为: ',num2str(mean(n))])disp([num2str(day),'个工作日中，银行每日客户的平均等待时间为: ',num2str(mean(t))])toc %计算tic和toc中间部分的代码的运行时间 matlab代码汇总 还有一些经典的问题这里不再赘述，题目很多，蒙特卡洛模拟主要是用其随机生成的思想来模拟问题的情况，用频率估计概率。遇到具体问题还要具体分析，这里汇总一些常用的matlab语句。 12345678910111213141516171819202122232425262728293031323334353637383940rand(m,n) %可以生成一个m行n列的矩阵，每个元素值在[0,1]之间rand(n) %只有一个值就是n*n的方阵a+rand(m,n)*(b-a) %可以生成一个m行n列的矩阵，每个元素值在[a,b]之间 等价于unifrnd(a,b,m,n)randi([a,b],m,n) %可在指定区间[a,b]内随机取出大小为m*n的整数矩阵normrnd(MU,SIGMA) %生成一个服从正态分布(MU参数代表均值,SIGMA参数代表标准差,方差开根号是标准差)的随机数exprnd(M) %表示生成一个均值为M的指数分布随机数(其对应的参数为1/M)mean[a,b,c] %用来求解均值的函数tic% tic函数和toc函数可以用来返回代码运行的时间a = 2^100tocformat long g %可以将Matlab的计算结果显示为一般的长数字格式（默认会保留四位小数，或使用科学计数法）unique([5 6 8 8 4 1 6 2 2 4 8 4 5 6]) %剔除一个矩阵或者向量的重复值，并将结果按照从小到大的顺序排列 randperm(5) % 生成1-5组成的一个随机序列(类似于洗牌的操作)find %假设a是一个向量，那么find(a)可以用来返回这个向量中非零元素的下标，如果a中所有元素都为0，则返回空值find(a) % 找到a中所有非0元素的位置find(a == 5) % 找到a中等于5的元素的位置find(a == 5,1) % 找到a中第一个等于5的元素的位置find(a == min(a)) % 找到a中最小元素的位置isempty(A) %函数可以用来判断A是否为空, 如果A为空， isempty(A) 返回逻辑值1(true)，否则返回逻辑值0(false)。randsrc(m,n,[alphabet; prob]) % 以一定的概率产生随机数% m和n表示生成的随机数矩阵的行数和列数% alphabet表示需要产生的随机数的数字，用一个行向量表示% prob表示这些数字出现的概率大小，用一个行向量表示，向量长度和alphabet向量要完全相同, 且这些概率的和要为1% 比如：要产生1、4、 6这三个数。它们分别出现的概率为 0.1、0.2、0.7，如何设计程序使得按照这个概率产生10个随机数呢？alphabet = [1 4 6]; prob = [0.1 0.2 0.7];randsrc(10,1,[alphabet; prob])","link":"/2023/01/11/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%A8%A1%E6%8B%9F/"},{"title":"数学建模笔记-多元回归分析","text":"回归分析的笔记-多元线性回归 概念 回归分析：研究X和Y的相关性分析 相关性不是因果性 统计数据可以说明：游泳死亡人数越高，雪糕卖的越多。（两者呈显著正相关） 但是不能说 吃雪糕会增加游泳死亡风险 背后的原因应该是天气热 所以相关性不是因果性 在大部分情况下都不能直接说是因果性 Y是因变量 是我们研究的核心变量 -因为别人的改变而改变的变量 连续性指数变量 -GDP -线性回归 0-1型变量 -对错 定序变量 -1表示非常不喜欢 5表示非常喜欢 计数变量 -一段时间内客户到访的次数 生存变量 -有截断的数据 比如人的年龄60+ X是自变量 回归分析的任务就是，通过研究X和Y的关系，尝试去解释Y的形成机制，从而达到通过X去预测Y的目的。 回归分析的使命 识别重要变量 不是所有变量都是有用的 逐步回归法 判断相关性的方向 正相关or负相关 要估计权重（回归系数） 去量纲处理 影响的大小 回归分析的分类 类型 模型 Y的特点 例子 线性回归 OLS,GLS 连续数值型变量 GDP 0-1回归 logistics回归 0-1变量 是否会违约 定序回归 probit定序回归 定序变量 等级评定 优良差 计数回归 泊松回归 计数变量 每分钟车流量 生存回归 Cox等比例风险回归 生存变量（截断数据） 企业、产品的寿命 数据的分类 数据类型 常见建模方法 横截面数据 多元线性回归 时间序列数据 移动平均、指数平滑、ARIMA、GARCH、VAR、协积 面板数据 固定效应和随机效应、静态面板和动态面板 横截面数据：在某一时点收集的不同对象的数据 例如：发放问卷得到的数据、各省份GDP的数据、大一新生今年体测得到的数据 时间序列数据：同一对象在不同时间连续观察所得到的数据 例如：每年生日的体重数据、中国历年来的GDP、在某地方每隔一小时测得的数据 面板数据：上面两者的综合 例如：2008-2018年，我国各省份GDP的数据 线性回归的学习 一元线性函数拟合-散点图-找最合适的y=kx+by=kx+by=kx+b 最小二乘法 假设x是自变量，y是因变量，且满足如下线性关系： yi=β0+β1xi+μiy_{i}=\\beta_{0}+\\beta_{1}x_{i}+\\mu_{i} yi​=β0​+β1​xi​+μi​ β0\\beta_{0}β0​和β1\\beta_{1}β1​为回归系数，μi\\mu_{i}μi​为无法观测的且满足一定条件的扰动项。 令预测值 yi^=β0^+β1^xi\\widehat{y_{i}}=\\widehat{\\beta_{0}}+\\widehat{\\beta_{1}}x_{i} yi​​=β0​​+β1​​xi​ 可以直接把预测值想象成拟合值 其中 β0^,β^1=arg⁡min⁡β0,β1(∑i=1n(yi−y^i)2)=arg⁡min⁡β0,β1(∑i=1n(yi−β^0−β^1xi)2)\\widehat{\\beta_{0}},\\widehat{\\beta}_{1}=\\underset{\\beta_{0}, \\beta_{1}}{\\arg \\min }\\left(\\sum_{i=1}^{n}\\left(y_{i}-\\widehat{y}_{i}\\right)^{2}\\right)=\\underset{\\beta_{0}, \\beta_{1}}{\\arg \\min }\\left(\\sum_{i=1}^{n}\\left(y_{i}-\\widehat{\\beta}_{0}-\\widehat{\\beta}_{1} x_{i}\\right)^{2}\\right) \\\\ β0​​,β​1​=β0​,β1​argmin​(i=1∑n​(yi​−y​i​)2)=β0​,β1​argmin​(i=1∑n​(yi​−β​0​−β​1​xi​)2) β^0,β^1=arg⁡min⁡β0,β1(∑i=1n(μ^i)2)\\widehat{\\beta}_{0}, \\widehat{\\beta}_{1}=\\underset{\\beta_{0}, \\beta_{1}}{\\arg \\min }\\left(\\sum_{i=1}^{n}\\left(\\widehat{\\mu}_{i}\\right)^{2}\\right) β​0​,β​1​=β0​,β1​argmin​(i=1∑n​(μ​i​)2) 我们称μi^=yi−β0^−β^1xi\\widehat{\\mu_{i}}=y_{i}-\\widehat{\\beta_{0}}-\\widehat{\\beta}_{1} x_{i}μi​​=yi​−β0​​−β​1​xi​为残差平方和 实际就是将优化问题转化为残差平方和最小 线性的概念 并不要求严格的线性关系，自变量和因变量可通过变量替换而转化成线性模型。 比如：lnx-&gt;z x+y-&gt;z 换元思想 所以需要对数据进行预处理 用Excel、matlab、stata等 回归系数的解释 引例： 假设x为某产品品质评分（连续数值），y为产品销量，现在对y和x进行一元线性回归。 如果得到结果yi^=3.4+2.3xi\\widehat{y_{i}}=3.4+2.3x_{i}yi​​=3.4+2.3xi​，其中： 3.4：在评分为0时，该产品的平均销量为3.4 2.3：评分每增加一个单位，该产品的平均销量增加2.3 如果现在有两个自变量，x1x_{1}x1​表示品质控分，x2x_{2}x2​表示该产品的价格，得到回归模型为yi^=5.3+0.19x1i−1.74x2i\\widehat{y_{i}}=5.3+0.19x_{1i}-1.74x_{2i}yi​​=5.3+0.19x1i​−1.74x2i​，其中： 5.3：在评分为0且价格为0时，平均销量为5.3。（实际情况下价格不可能为0，所以没有现实意义，写论文可以不写截距项） 0.19：在其他变量不变时，评分每增加一个单位，该产品的平均销量增加0.19 1.74：同理可解释 对比可知，在引入了新的自变量价格之后，对回归系数的影响非常大，从3.4变成2.3 原因：遗漏变量导致的内生性 内生性的探究 假设一个模型有k个自变量，其中μi\\mu_{i}μi​为扰动项，如果满足μi\\mu_{i}μi​和所有的自变量x都不相关，则称该回归模型具有外生性，反正则存在内生性，内生性会导致回归系数估计的不准确：不满足无偏(计算期望值，可以理解为代表性)和一致性(计算极限，排除n的大小) 在之前的例子中μi\\mu_{i}μi​包含了所有与y相关，但未添加到回归模型中的变量，如果这些变量与已经添加的自变量相关（例子中价格和销量相关），则存在内生性。 为了避免这种情况，需要尽可能多的列出因变量，或者用工具变量解决，即寻找一个新的变量来代替目前的变量。 代码实现：利用蒙特卡洛模拟证明内生性会造成回归系数的巨大误差 核心解释变量和控制变量 由于无内生性的假设太强，要求所有解释变量均与扰动项不相关是很难的，所以寻求一种弱化条件的办法，即讲解释变量分为核心解释变量与控制变量两类。 核心解释变量：我们最感兴趣的变量，因此我们特别希望得到对其系数的一致估计（当样本容量无限增大时，收敛于待估计参数的真值）。 控制变量：我们可能对于这些变量本身并无太大兴趣；而之所以把它们也放入回归方程，主要是为了 “控制住” 那些对被解释变量有影响的遗漏因素。 在实际应用中，我们只要保证核心解释变量与𝝁不相关即可。 回到公式上 yi=β0+β1x1i+β2x2i+⋯+βkxki+μi⇓y^i=β0^+β1^x1i+β2^x2i+⋯+β^kxki\\begin{array}{c} y_{i}=\\beta_{0}+\\beta_{1} x_{1 i}+\\beta_{2} x_{2 i}+\\cdots+\\beta_{k} x_{k i}+\\mu_{i} \\\\ \\Downarrow \\\\ \\hat{y}_{i}=\\widehat{\\beta_{0}}+\\widehat{\\beta_{1}} x_{1 i}+\\widehat{\\beta_{2}} x_{2 i}+\\cdots+\\widehat{\\beta}_{k} x_{k i} \\end{array} yi​=β0​+β1​x1i​+β2​x2i​+⋯+βk​xki​+μi​⇓y^​i​=β0​​+β1​​x1i​+β2​​x2i​+⋯+β​k​xki​​ β^0\\widehat{\\beta}_{0}β​0​作为截距项，数值意义一般不考虑，显示情况中很少存在自变量全为0的。 βm^(m=1,2,⋯ ,k)\\widehat{\\beta_{m}}(m=1,2, \\cdots, k)βm​​(m=1,2,⋯,k)：控制其他自变量不变的情况下，xmix_{mi}xmi​每增加一个单位，对yiy_{i}yi​造成的变化。（看系数正的就是多，负的就是少） 实际上可以用偏导数来定义，在很多教材里也把多元线性回归模型中的回归系数称为偏回归系数。 βm^=∂yi∂xmi\\widehat{\\beta_{m}}=\\frac{\\partial y_{i}}{\\partial x_{m i}} βm​​=∂xmi​∂yi​​ 关于取对数： 之前讲换元的时候有讲到可以取对数，其实在应用中经常用到对数概念。 伍德里奇的《计量经济学导论，现代观点》里，第六章176-177页有详细的论述； 取对数意味着原被解释变量对解释变量的弹性，即百分比的变化而不是数值的变化； 目前，对于什么时候取对数还没有固定的规则，但是有一些经验法则： （1）与市场价值相关的，例如，价格、销售额、工资等都可以取对数； （2）以年度量的变量，如受教育年限、工作经历等通常不取对数； （3）比例变量，如失业率、参与率等，两者均可； （4）变量取值必须是非负数，如果包含0，则可以对y取对数ln(1+y); 取对数的好处： 减弱数据的异方差性 如果变量本身不符合正态分布，取了对数后可能渐近服从正态分布 模型形式的需要，让模型具有经济学意义 具体文字解释： 一元线性回归：𝑦=𝑎+𝑏𝑥+𝜇，x每增加1个单位，y平均变化b个单位； 双对数模型：𝑙𝑛𝑦=𝑎+𝑏𝑙𝑛𝑥+𝜇，x每增加1%，y平均变化b%； 半对数模型：𝑦=𝑎+𝑏𝑙𝑛𝑥，x每增加1%，y平均变化b/100个单位； 半对数模型：𝑙𝑛𝑦=𝑎+𝑏𝑥，x每增加1个单位，y平均变化(100b)%。 虚拟变量X 当出现定性变量，比如性别，地域等，就需要把定性变量转化为定量变量，即虚拟变量。 例如：研究性别对于工资的影响 yi=β0+δ0Femalei+β1x1i+β2x2i+⋯+βkxki+μiy_{i}=\\beta_{0}+\\delta_{0} \\text {Female}_{i}+\\beta_{1} x_{1 i}+\\beta_{2} x_{2 i}+\\cdots+\\beta_{k} x_{k i}+\\mu_{i} yi​=β0​+δ0​Femalei​+β1​x1i​+β2​x2i​+⋯+βk​xki​+μi​ Femalei=1\\text {Female}_{i}=1Femalei​=1表示第i个样本为女性；Femalei=0\\text {Female}_{i}=0Femalei​=0表示为男性 核心解释变量为：Female 控制变量为：地域、年纪等等 由于控制变量等等都是定值，这里全部记为C。 E(y∣ Female =1 以及其他自变量给定 )=δ0×1+CE(y∣ Female =0 以及其他自变量给定 )=δ0×0+CE(y∣ Female =1 以及其他自变量给定 )−E(y∣ Female =0 以及其他自变量给定 )=δ0\\begin{aligned} &amp; E(y \\mid \\text { Female }=1 \\text { 以及其他自变量给定 })=\\delta_{0} \\times 1+C \\\\ &amp; E(y \\mid \\text { Female }=0 \\text { 以及其他自变量给定 })=\\delta_{0} \\times 0+C \\\\ E(y \\mid \\text { Female }= &amp; 1 \\text { 以及其他自变量给定 })-E(y \\mid \\text { Female }=0 \\text { 以及其他自变量给定 })=\\delta_{0} \\end{aligned} E(y∣ Female =​E(y∣ Female =1 以及其他自变量给定 )=δ0​×1+CE(y∣ Female =0 以及其他自变量给定 )=δ0​×0+C1 以及其他自变量给定 )−E(y∣ Female =0 以及其他自变量给定 )=δ0​​ 因此δ0\\delta_{0}δ0​可解释为：在其他自变量给定的情况下, 女性的平均工资与男性的平均工资的差异。 当然还要考虑其显著性才能说明问题。 为了避免完全多重共线性的影响，引入虚拟变量为分类数减一。 含有交互项的自变量 因变量对一个解释变量的偏效应（最正常的）、弹性（双对数模型）、半弹性（半弹性模型），有时取决于另一个解释变量的大小，比如有一个因子为x1∗x2x_{1}*x_{2}x1​∗x2​，若系数＞0，x1x_{1}x1​越大，x2x_{2}x2​的增加就会导致y上升越大，这就说明两个变量间有交互效应。 实操1 问题引例 数据的描述性统计 使用stata软件: 定量数据：summarize 变量1 变量2 … 变量n 定性数据：tabulate 变量名,gen(A) 返回对应的这个变量的频率分布表，并生成对应的虚拟变量(以A开头)，很好用，可以在stata里直接生成并查看虚拟变量 做表/做图：使用excel的数据透视表/数据透视图功能 解释性回归分析-解决问题一 stata语法：regress y x1 x2 … xk 默认使用OLS：普通最小二乘估计法 Modle:SSR Residual:SSE Total:SST df:自由度 MS:平均自由度 p值＜0.05可以拒绝原假设（原假设H0：系数全都=0），才能通过联合显著性检验。 检验回归系数：用的t检验 原假设H0H_{0}H0​：βi=0\\beta_{i}=0βi​=0 p值＜0.05代表在95%置信水平下，拒绝原假设，即该回归系数显著异于0。 当加入定性数据时： 运用前面讲的生成虚拟变量 reg 评价量 G1 G2 G3 G4 为了避免完全多重共线性的影响，引入虚拟变量为分类数减一。所以随机删除一个变量作为对照组，这里删除的是G4。 因此G1的回归系数为G1的评价量-G4的评价量，在其他变量不变时，段位为1的评价量比段位为4的评价量平均要（多/少 系数值） 当然需要注意显著性检验，只有通过显著性检验的自变量才有意义。 拟合优度低怎么办： （1）回归分为解释型回归和预测型回归。预测型回归一般才会更看重R2R^{2}R2。(可以理解成拟合，R2R^{2}R2越大效果才越好) 解释型回归更多的关注模型整体显著性以及自变量的统计显著性和经济意义显著 性即可。 （2）可以对模型进行调整，例如对数据取对数或者平方后再进行回归。（数据维度的改变） （3）数据中可能有存在异常值或者数据的分布极度不均匀。 调整后的拟合优度： 我们引入的自变量越多，拟合优度会变大。但我们倾向于使用调整后的拟合优度，如果新引入的自变量对SSE的减少程度特别少，那么调整后的拟合优度反而会减小。 R2=1−SSESSTSSE=∑i=1n(Yi−Y^i)2Radjusted 2=1−SSE/(n−k−1)SST/(n−1)(k为自变量的个数)\\begin{array}{l} R^{2}=1-\\frac{S S E}{S S T} \\quad S S E=\\sum_{i=1}^{n}\\left(Y_{i}-\\widehat{Y}_{i}\\right)^{2} \\\\ R_{\\text {adjusted }}^{2}=1-\\frac{S S E /(n-k-1)}{S S T /(n-1)}(k \\text {为自变量的个数}) \\end{array} R2=1−SSTSSE​SSE=∑i=1n​(Yi​−Yi​)2Radjusted 2​=1−SST/(n−1)SSE/(n−k−1)​(k为自变量的个数)​ 拟合值出现负值的原因：y分布极度不平衡 标准化回归系数-解决问题二 为了去除量纲的影响，考虑使用标准化回归系数。 对数据进行标准化，就是将原始数据减去它的均数后，再除以该变量的标差，计算得到新的变量值，新变量构成的回归方程称为标准化回归方程，回归后相应可得到标准化回归系数。 标准化系数的绝对值越大，说明对因变量的影响就越大（只关注显著的回归系数哦）。 stata语法：regress y x1 x2 … xk ,beta 常数项没有标准化系数，因为常数项的均值是本身，减去之后直接变成0了。 对数据进行标准化处理不会影响回归系数的标注误，也不会影响显著性。 扰动项要满足的条件 默认扰动项是球型扰动项。球型扰动项：满足“同方差”和“无自相关”两个条件。 但是横截面数据容易出现异方差的问题，时间序列数据容易出现自相关的问题。 异方差问题 如果扰动项存在异方差： （1）OLS估计出来的回归系数是无偏、一致的。 （2）假设检验无法使用（构造的统计量失效了）。 （3）OLS估计量不再是最优线性无偏估计量（BLUE）。 检验异方差： 通过图形： stata语法：rvfplot （残差与拟合值的散点图） rvpplot x （残差与自变量x的散点图） graph export a1.png,replace 通过假设检验： 一般使用怀特检验 H0H_{0}H0​:不存在异方差 stata语法（在回归结束后使用）：estat imtest,white p值＜0.05，拒绝原假设，即存在异方差。 解决办法： （1）OLS+稳健的标准误（因为假设检验失效了） （2）GLS（原理：方差小的数据包含的信息较多，可以给方差大的数据更大的权重）缺点：不知道扰动项真实的协方差矩阵 存在偶然性 推荐使用（1） stata语法： regress y x1 x2 … xk,robust 多重共线性 先前定性变量制造虚拟变量的时候，stata提出了一个变量来避免多重共线性。 多重共线性的存在会导致：（1）虽然R2R^{2}R2很大、F检验也很显著，但单个t检验却不显著。 （2）加入一个新的变量，对前面的系数估计值产生很大的影响。（类似于内生性） 检验多重共线性： 定义回归模型的VIF=max⁡{VIF1,VIF2,⋯ ,VIFk}VIF=\\max \\left\\{VIF_{1}, VIF_{2}, \\cdots, VIF_{k}\\right\\}VIF=max{VIF1​,VIF2​,⋯,VIFk​} 如果VIM&gt;10，则认为该回归方程有严重的多重共线性。 stata语法：estat vif 解决办法： （1）如果是预测性回归，不用管多重共线性，只需要关注拟合优度就行了。 （2）如果多重共线性并不影响所关心变量的显著性，也可以不管，因为如果没有多重共线性，结果只会更显著。 （3）如果影响到所关心变量的显著性，需要增加样本容量（难），剔除导致严重共线性的变量（但是要注意内生性），或对建模进行修改。 逐步回归 向前逐步回归 将自变量逐个引入模型，每引入一个自变量后都要进行检验，显著时才加入回归模型。(缺点：随着以后其他自变量的引入，原来显著的自变量也可能又变为不显著了，但是，并没有将其及时从回归方程中剔除掉。) stata语法：stepwise regress y x1 x2 … xk, pe(#1) #1就是显著性水平，只将显著的加入模型中。（p值＜#1） 向后逐步回归 与向前逐步回归相反，先将所有变量均 放入模型，之后尝试将其中一个自变量从模型中剔除，看整个模型解释因变量的变异是否有显著变化，之后将最没有解释力的那个自变量剔除；此过程不断迭代，直到没有自变量符合剔除的条件。（缺点：一开始把全部变量都引入回归方程，这样计算量比较大。若对一些不重要的变量，一开始就不引入，这样就可以减少一些计算。当然这个缺点随着现在计算机的能力的提升，已经变得不算问题了。） stata语法：stepwise regress y x1 x2 … xk, pr(#2) #2也是显著性水平，不显著就会被剔除模型。 说明 如果筛选后的变量太多了，可以减小#1或者#2，太少同理。 注：（1）自变量之间不能有完全多重共线性，与regress不同，需要手动剔除。 （2）可以在后面再加参数b和r，即标准化回归系数或稳健标准误 （3）向前逐步回归和向后逐步回归的结果可能不同。 （4）不要轻易使用逐步回归分析（数模论文没事），因为剔除了自变量后很有可能会产生新的问题，例如内生性问题。 （5）更加优秀的筛选方法：每种情况都尝试一次，最终一共有Ck1+Ck2+⋯+Ckk=2k−1C_{k}^{1}+C_{k}^{2}+\\cdots+C_{k}^{\\mathrm{k}}=2^{k}-1Ck1​+Ck2​+⋯+Ckk​=2k−1种可能。如果自变量很多，那么计算相当费时。（不太现实 一般不用 还是逐步回归就行）","link":"/2023/01/10/%E5%A4%9A%E5%85%83%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/"},{"title":"problem02","text":"记设置hexo支持mermaid与部署GitHub报错的问题 hexo支持mermaid 前段时间写了流程图，但是发现hexo渲染并没有成功，记一下方法。 mermaid官方文档 如果主题本身自带了mermaid，只需要在config里改mermaid: true即可，以下方法针对没有mermaid的主题。 安装hexo插件 1npm i hexo-filter-mermaid-diagrams npm安装插件的时候会出现以下语句： 1234up to date in 943ms24 packages are looking for funding run `npm fund` for details 这不是报错，如果不想出现这个可以输入 1npm install --no-fund 配置 在config文件里加入以下代码 123456# mermaid chartmermaid: ## mermaid url https://github.com/knsv/mermaid enable: true # default true version: &quot;8.13.8&quot; # default v7.1.2 options: # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js #startOnload: true // default true 主题配置 找到themes\\你的主题名字\\layout\\_partials\\footer.pug文件，加入这一行代码即可 1script(src=&quot;https://cdn.bootcdn.net/ajax/libs/mermaid/8.13.8/mermaid.min.js&quot;) 如果footer文件是用别的语言写的，可以参考这篇博客，里面有其他语言的方法。 遇到的问题 第一步安装包很关键，第一次配置没有成功，应该下载的时候出现了问题，可以尝试去原GitHub下载，放到node_modules里面，也可以多试几次。 第二步我这里好像没设置也可以照样渲染成功。 GitHub部署报错的问题 前段时间用hexo d部署的时候总是报错 我遇到的问题是 1234567fatal: unable to access 'https://github.com/wxhxyyzm/wxhxyyzm.github.io.git/': OpenSSL SSL_read: Connection was reset, errno 10054FATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess.&lt;anonymous&gt; (D:\\Ahh\\node_modules\\hexo-util\\lib\\spawn.js:51:21) at ChildProcess.emit (node:events:513:28) at ChildProcess.cp.emit (D:\\Ahh\\node_modules\\cross-spawn\\lib\\enoent.js:34:29) at Process.ChildProcess._handle.onexit (node:internal/child_process:291:12) 不过这个是时好时坏，有的时候可以成功，有的时候不行。 后来看了帖子，找到一种最简单的方法 把config里deploy中repo的形式改掉 注释掉的是之前用的 改成git@…之后再也没有报错过了 12345deploy: type : git ## repo : https://github.com/wxhxyyzm/wxhxyyzm.github.io.git repo: git@github.com:wxhxyyzm/wxhxyyzm.github.io.git branch : master","link":"/2023/01/18/problem02/"},{"title":"数学建模笔记-分类模型","text":"二分类（逻辑回归+fisher线性判别）与多分类模型 引例 数据预处理 由于水果类别是文字信息，所以要将定性数据转化成0-1变量 SPSS操作： graph LR A[转换] --> B(创建虚变量) --> C(删除多余的变量 只保留一组) --> D(修改变量名字-例子中为isapple) 逻辑回归本质还是回归分析的一种，对于因变量为分类变量的情况，我们可以把y看成事件发生的概率，y≥0.5y\\ge0.5y≥0.5表示发生；y&lt;0.5y\\lt0.5y&lt;0.5表示不发生。 逻辑回归 线性概率模型 yi=β0+β1x1i+β2x2i+⋯+βkxki+μiy_{i}=\\beta_{0}+\\beta_{1} x_{1 i}+\\beta_{2} x_{2 i}+\\cdots+\\beta_{k} x_{k i}+\\mu_{i} yi​=β0​+β1​x1i​+β2​x2i​+⋯+βk​xki​+μi​ 写成向量乘积形式(简写一下): yi=xi′β+ui(i=1,2,⋯ ,n)y_{i}=\\boldsymbol{x}_{\\boldsymbol{i}}^{\\prime} \\boldsymbol{\\beta}+u_{i}(i=1,2, \\cdots, n) yi​=xi′​β+ui​(i=1,2,⋯,n) 问题一： 内生性（看扰动项与自变量是否相关）：y0y_{0}y0​只能取1或者0 ui={1−xi′β,yi=1−xi′β,yi=0u_{i}=\\left\\{\\begin{array}{cc} 1-\\boldsymbol{x}_{\\boldsymbol{i}}^{\\prime} \\boldsymbol{\\beta} &amp; , y_{i}=1 \\\\ -\\boldsymbol{x}_{\\boldsymbol{i}}^{\\prime} \\boldsymbol{\\beta} &amp; , y_{i}=0 \\end{array}\\right. ui​={1−xi′​β−xi′​β​,yi​=1,yi​=0​ 显然cov⁡(xi,ui)≠0\\operatorname{cov}(x_{i}, u_{i}) \\neq 0cov(xi​,ui​)​=0，因此会有内生性问题，就会导致回归系数估计出来不一致且有偏。 问题二： 由于把y看成事件发生的概率，但yi^=β0^+β1^x1i+β2^x2i+⋯+βk^xki\\widehat{y_{i}}=\\widehat{\\beta_{0}}+\\widehat{\\beta_{1}} x_{1 i}+\\widehat{\\beta_{2}} x_{2 i}+\\cdots+\\widehat{\\beta_{k}} x_{k i}yi​​=β0​​+β1​​x1i​+β2​​x2i​+⋯+βk​​xki​，预测值可能出现yi^&gt;1\\widehat{y_{i}}\\gt1yi​​&gt;1或yi^&lt;0\\widehat{y_{i}}\\lt0yi​​&lt;0的不现实情况 解决方法 由于二分类，因此可以看成是伯努利分布。 事件 1 0 概率 p 1-p 在给定x\\boldsymbol{x}x的情况下，考虑y的情况如下： {P(y=1∣x)=F(x,β)P(y=0∣x)=1−F(x,β)\\left\\{\\begin{array}{l} P(y=1 \\mid \\boldsymbol{x})=F(\\boldsymbol{x}, \\boldsymbol{\\beta}) \\\\ P(y=0 \\mid \\boldsymbol{x})=1-F(\\boldsymbol{x}, \\boldsymbol{\\beta}) \\end{array}\\right. {P(y=1∣x)=F(x,β)P(y=0∣x)=1−F(x,β)​ (一般F(x,β)=F(xi′β)F(\\boldsymbol{x}, \\boldsymbol{\\beta})=F(\\boldsymbol{x}_{\\boldsymbol{i}}^{\\prime} \\boldsymbol{\\beta})F(x,β)=F(xi′​β)) F(x,β)F(\\boldsymbol{x}, \\boldsymbol{\\beta})F(x,β)被称为连接函数，只需要保证F(x,β)F(\\boldsymbol{x}, \\boldsymbol{\\beta})F(x,β) 是定义在[0,1][0,1][0,1] 上的函数（注意这里的 [0,1][0,1][0,1]是值域)，就能保证0≤y^≤10 \\leq \\hat{y} \\leq 10≤y^​≤1。 计算E(y∣x)E(y \\mid \\boldsymbol{x})E(y∣x)可知其等于P(y=1∣x)P(y=1 \\mid \\boldsymbol{x})P(y=1∣x)，因此可以用yi^\\widehat{y_{i}}yi​​来作为分类的依据。 连接函数的取法： 1.正态分布（probit回归） 2.Sigmoid函数（logistic回归） 一般用logistic回归，因为Sigmoid函数表示形式简单一点，有解析表达式，便于后续操作。 F(x,β)=S(xi′β)=exp⁡(xi′β)1+exp⁡(xi′β)F(\\boldsymbol{x}, \\boldsymbol{\\beta})=S\\left(\\boldsymbol{x}_{\\boldsymbol{i}}^{\\prime} \\boldsymbol{\\beta}\\right)=\\frac{\\exp \\left(\\boldsymbol{x}_{\\boldsymbol{i}}^{\\prime} \\boldsymbol{\\beta}\\right)}{1+\\exp \\left(\\boldsymbol{x}_{\\boldsymbol{i}}^{\\prime} \\boldsymbol{\\beta}\\right)} F(x,β)=S(xi′​β)=1+exp(xi′​β)exp(xi′​β)​ 操作说明 yi^=P(yi=1∣x)=S(xi′β^)=exp⁡(xi′β^)1+exp⁡(xi′β^)=eβ0^+β^1x1i+β^2x2i+⋯+β^kxki1+eβ^0+β^1x1i+β^2x2i+⋯+β^kxki\\widehat{y_{i}}=P\\left(y_{i}=1 \\mid \\boldsymbol{x}\\right)=S\\left(\\boldsymbol{x}_{\\boldsymbol{i}}^{\\prime} \\hat{\\boldsymbol{\\beta}}\\right)=\\frac{\\exp \\left(\\boldsymbol{x}_{\\boldsymbol{i}}^{\\prime} \\hat{\\boldsymbol{\\beta}}\\right)}{1+\\exp \\left(\\boldsymbol{x}_{\\boldsymbol{i}}^{\\prime} \\hat{\\boldsymbol{\\beta}}\\right)}=\\frac{e^{\\widehat{\\beta_{0}}+\\widehat{\\beta}_{1} x_{1 i}+\\widehat{\\beta}_{2} x_{2 i}+\\cdots+\\widehat{\\beta}_{k} x_{ki}}}{1+e^{\\widehat{\\beta}_{0}+\\widehat{\\beta}_{1} x_{1 i}+\\widehat{\\beta}_{2} x_{2 i}+\\cdots+\\widehat{\\beta}_{k} x_{ki}}}yi​​=P(yi​=1∣x)=S(xi′​β^​)=1+exp(xi′​β^​)exp(xi′​β^​)​=1+eβ​0​+β​1​x1i​+β​2​x2i​+⋯+β​k​xki​eβ0​​+β​1​x1i​+β​2​x2i​+⋯+β​k​xki​​ 非线性模型，使用极大似然估计（MLE）进行估计，求出yi^\\widehat{y_{i}}yi​​。 实际上相较于线性概率模型多了一个限制，使得值域能控制在[0,1][0,1][0,1]内。 SPSS求预测值的操作： graph LR A[分析] --> B(回归) --> C(二元logistic回归) C--> D(因变量放入刚刚处理好的分类) C--> E(自变量放入其他指标) C--> F(分类:将定量变量转化为定性变量) C--> G(保存:勾选概率和组成员) C--> H(逐步回归可以在方法里面设置) 结果分析： 仅有四个指标的预测成功率如下： 由显著性可以看出，回归的效果还是很好的，变量之间相关性小。 预测成功率不高怎么办：可在模型中加入平方项、交互项等 SPSS操作：转换-计算变量 但是容易发生过拟合现象：容易发现显著性变得很差。 导致对于样本数据的预测非常好，但是对于样本外的数据的预测效果可能会很差。 如何确定合适的模型 把数据分为训练组和测试组，用训练组的数据来估计出模型，再用测试组的数据来进行测试。（训练组和测试组的比例一般设置为80%和20%) 已知分类结果的水果ID为1‐38，前19个为苹果，后19个为橙子。 每类水果中随机抽出3个ID作为测试组，剩下的16个ID作为训练组。（比如：17‐19、36‐38这六个样本作为测试组） 比较设置不同的自变量后的模型对于测试组的预测效果。 （注意：为了消除偶然性的影响，可以对上述步骤多重复几次，最终对每个模型求一个平均的准确率，这个步骤称为交叉验证。） Fisher线性判别分析 寻找一个超平面分割所有的样例，所以核心问题就转化成了，寻找线性系数ω\\omegaω。 SPSS操作说明 graph LR A[分析] --> B(分类) --> C(判别式) C--> D(分组变量:y 定义范围最小值:0 最大值:1) C--> E(统计:勾选费希尔和为标准化) C--> F(分类:勾选摘要表) C-->G(保存:勾选预测组成员和组成员概率) 得到的效果与成功率差不多，会得到一个分类函数系数表，即贝叶斯判别函数系数表，将样品的各参数带入2个贝叶斯判别函数，比较得出的函数值，哪个函数值较大就将该样品归于哪一类。 论文里要放线性系数向量、成功率和结果 多分类 fisher 参考链接 SPSS:分组变量那边设置最小值：1 最大值：n(n表示n类别) Logistic 将连接函数：Sigmoid函数 推广为 Softmax函数 参考链接 当成功率过于高的时候，要注意过拟合问题。","link":"/2023/01/18/%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/"},{"title":"数学建模笔记-时间序列","text":"时间序列也称动态序列，是指将某种现象的指标数值按照时间顺序排列而成的数值序列。 时间序列分析大致可分成三大部分，分别是描述过去、分析规律和预测未来。 时间序列数据 组成要素：时间（年、季度、月份等）+数值 时间序列根据时间和数值性质的不同，可以分为时期时间序列和时点时间序列。 时期序列中，数值要素反映现象在一定时期内发展的结果 如中国2018-2019的GDP增长 时点序列中，数值要素反映现象在一定时点上的瞬间水平 如从出生到现在体重的增长 时期序列可以相加 时点序列不行 时间序列分析 graph LR A(时间序列分析)-->B(描述过去:描述时间序列的动态变化) A(时间序列分析)-->C(分析规律:揭示数值背后的变化规律) A(时间序列分析)-->D(预测未来:根据规律预测未来趋势) 步骤 作时间序列图 判断时间序列包含的变动成分 时间序列分解（有周期性且包含长期趋势、季节变动或循环变动） 建立时间序列分析模型 预测未来的指标数值 时间序列分解 一般情况下，时间序列的数值变化规律有： 长期变动趋势T 季节变动趋势S （月份、季节、周都可以为单位 不能以年为单位） 循环变动趋势C 不规则变动I（随机扰动项） 一个时间序列往往是以上四类变化形式的叠加。 如果四种变动相互独立，那么叠加模型为$$Y=T+S+C+I$$ 如果四种变动相互影响，那么乘积模型为$$Y=TSC*I$$ 注：（1）数据具有年内的周期性时才能使用时间序列分解，例如数据是月份数据(周期为12)、季度数据(周期为4) ，如果是年份数据则不行。 （2）在具体的时间序列图上，如果随着时间的推移，序列的季节波动变得越来越大，则反映各种变动之间的关系发生变化，建议使用乘积模型； 反之，如果时间序列图的波动保持恒定，则可以直接使用叠加模型；当然，如果不存在季节波动，则两种分解均可以。 SPSS处理时间序列中的缺失值 缺失值如果在收尾直接删除 如果在中间就用SPSS处理 操作：转换——替换缺失值——选择方法 方法： 序列平均值 用整个序列的平均数代替缺失值 临近点的平均值 用相邻若干个点的平均数来替换缺失值（默认为两个点） 临近点的中位数 用相邻若干个点的中位数来替换缺失值（默认为两个点） 线性插值 用相邻两个点的平均数来替换缺失值 邻近点的线性趋势 将时期数作为x，时间序列值作为y进行回归，求缺失点的预测值 SPSS定义时间变量 操作：数据——定义日期和时间——选择并设置起始时间 SPSS做时间序列图 操作：分析——时间序列预测——序列图 作图都需要有解释性文字 季节性分解 操作：分析——时间序列预测——季节性分解——根据分析选择乘法/加法——移动平均值权重需要根据周期的奇偶性选择 （奇数选择所有点相等 偶数选择端点按0.5加权） ERR:I SAS:T+C+I SAF:S STC:T+C 解读季节因子 加法分解： 所有季节因子和为0 以按季度分的销售水平为例子 若第一季度第二季度季节因子为正，说明该产品第一季度平均销量要高于第三季度第四季度，且第一季度的平均销量要高于全年平均水平的（季节因子）件 乘法分解： 所有季节因子乘积为1 若第一季度第二季度季节因子大于1，说明该产品第一季度平均销量要高于第三季度第四季度，且第一季度的平均销量要是全年平均水平的（季节因子）倍 画出分解后的时序图 操作：分析——时间序列预测——序列图——把刚刚分解的变量都加进去 时间序列分析模型 指数平滑模型 simple模型 适用条件：不含趋势和季节成分 约等于ARIMA(0,1,1) SPSS会自动选好平滑系数。 弊端：只能预测一期 因为在计算第二个时xt+1=x^t+1x_{t+1}=\\hat{x}_{t+1}xt+1​=x^t+1​，代入公式会得到x^t+2=x^t+1\\hat{x}_{t+2}=\\hat{x}_{t+1}x^t+2​=x^t+1​，因此只能预测一期的值 线性趋势模型 适用条件：不含季节成分、线性趋势 论文里要把各个公式写出来 阻尼趋势模型 适用条件：不含季节成分、线性趋势逐渐减弱 简单季节模型 适用条件：稳定的含季节成分、不含趋势 温特加法模型 适用条件：含有线性趋势和稳定的季节成分 温特乘法模型 适用条件：含有线性趋势和不稳定的季节成分 一元时间序列分析的模型 时间序列的平稳性 若时间序列{xt}\\left\\{x_t\\right\\}{xt​}满足以下三个条件，则{xt}\\{x_{t}\\}{xt​}为协方差平稳，又称弱平稳： (1) E(xt)=E(xt−s)=uE\\left(x_t\\right)=E\\left(x_{t-s}\\right)=uE(xt​)=E(xt−s​)=u (均值为固定常数) (2) Var⁡(xt)=Var⁡(xt−s)=σ2\\operatorname{Var}\\left(x_t\\right)=\\operatorname{Var}\\left(x_{t-s}\\right)=\\sigma^2Var(xt​)=Var(xt−s​)=σ2 (方差存在且为常数 即不存在异方差) (3) Cov⁡(xt,xt−s)=γs\\operatorname{Cov}\\left(x_t, x_{t-s}\\right)=\\gamma_sCov(xt​,xt−s​)=γs​ (协方差只和间隔 sss 有关, 与 ttt 无关 ))) 若时间序列 {xt}\\left\\{x_t\\right\\}{xt​} 满足以下三个条件: (1) E(xt)=E(xt−s)=0E\\left(x_t\\right)=E\\left(x_{t-s}\\right)=0E(xt​)=E(xt−s​)=0 (2) Var⁡(xt)=Var⁡(xt−s)=σ2\\operatorname{Var}\\left(x_t\\right)=\\operatorname{Var}\\left(x_{t-s}\\right)=\\sigma^2Var(xt​)=Var(xt−s​)=σ2 (方差存在且为常数) (3) Cov⁡(xt,xt−s)=0(s≠0)\\operatorname{Cov}\\left(x_t, x_{t-s}\\right)=0(s \\neq 0)Cov(xt​,xt−s​)=0(s​=0) 则称 {xt}\\left\\{x_t\\right\\}{xt​} 为白噪声序列(white noise)。白噪声序列是平稳时间序列的一个特例。 差分方程 将某个时间序列变量表示为该变量的滞后项、时间和其他变量的函数, 这样的一个函数方程被称为差分方程。 yt=α0+α1yt−1+α2yt−2+⋯+αpyt−p+εt （自回归AR (p) 模型） yt=εt+β1εt−1+β2εt−2+⋯+βqεt−q （移动平均MA (q) 模型） yt=α0+∑i=1pαiyt−i+εt+∑i=1qβiεt−i （自回归移动平均ARMA (p,q) 模型） yt=a+byt−1+czt+dzt−1+εtyt=a+byt−1+ct+εt\\begin{aligned} &amp; y_t=\\alpha_0+\\alpha_1 y_{t-1}+\\alpha_2 y_{t-2}+\\cdots+\\alpha_p y_{t-p}+\\varepsilon_t \\quad \\text { （自回归AR }(p) \\text { 模型） } \\\\ &amp; y_t=\\varepsilon_t+\\beta_1 \\varepsilon_{t-1}+\\beta_2 \\varepsilon_{t-2}+\\cdots+\\beta_q \\varepsilon_{t-q} \\quad \\text { （移动平均MA }(q) \\text { 模型） } \\\\ &amp; y_t=\\alpha_0+\\sum_{i=1}^p \\alpha_i y_{t-i}+\\varepsilon_t+\\sum_{i=1}^q \\beta_i \\varepsilon_{t-i} \\quad \\text { （自回归移动平均ARMA }(p, q) \\text { 模型） } \\\\ &amp; y_t=a+b y_{t-1}+c z_t+d z_{t-1}+\\varepsilon_t \\\\ &amp; y_t=a+b y_{t-1}+c t+\\varepsilon_t\\\\ \\end{aligned} ​yt​=α0​+α1​yt−1​+α2​yt−2​+⋯+αp​yt−p​+εt​ （自回归AR (p) 模型） yt​=εt​+β1​εt−1​+β2​εt−2​+⋯+βq​εt−q​ （移动平均MA (q) 模型） yt​=α0​+i=1∑p​αi​yt−i​+εt​+i=1∑q​βi​εt−i​ （自回归移动平均ARMA (p,q) 模型） yt​=a+byt−1​+czt​+dzt−1​+εt​yt​=a+byt−1​+ct+εt​​ 差分方程的齐次部分：只包含该变量自身和它的滞后项的式子。 yt=α0+∑i=1pαiyt−i+εt+∑i=1qβiεt−i （ARMA (p,q) 模型） y_t=\\alpha_0+\\sum_{i=1}^p \\alpha_i y_{t-i}+\\varepsilon_t+\\sum_{i=1}^q \\beta_i \\varepsilon_{t-i} \\quad \\text { （ARMA }(p, q) \\text { 模型） } yt​=α0​+i=1∑p​αi​yt−i​+εt​+i=1∑q​βi​εt−i​ （ARMA (p,q) 模型） 齐次部分: yt=∑i=1pαiyt−iy_t=\\sum_{i=1}^p \\alpha_i y_{t-i}yt​=∑i=1p​αi​yt−i​ 将齐次部分转换为特征方程(代数方程): 令 yt=xty_t=x^tyt​=xt 后带入齐次方程化简 $$xt=\\sum_{i=1}p \\alpha_i x^{t-i} \\Rightarrow x^p=\\alpha_1 x^{p-1}+\\alpha_2 x^{p-2}+\\cdots+\\alpha_p$$(同时除以 xt−px^{t-p}xt−p 即可) 特征方程是一个 ppp 阶多项式, 对应可求出 ppp 个解 (可能有实根, 也可能有虚根) 这 ppp 个解的模长 (实根取绝对值, 虚根取模) 的大小决定了形为ARMA (p,q)(p, q)(p,q) 模型的 {yt}\\left\\{y_t\\right\\}{yt​} 是否平稳。 滞后算子:Liyt=yt−iL^{i}y_t=y_{t-i}Liyt​=yt−i​ 满足结合律、分配律 ARMA⁡(p,q)\\operatorname{ARMA}(p, q)ARMA(p,q) 模型: yt=α0+∑i=1pαiyt−i+εt+∑i=1qβiεt−i⇒yt=α0+∑i=1pαiLiyt+εt+∑i=1qβiLiεt⇒(1−∑i=1pαiLi)yt=α0+(1+∑i=1qβiLi)εt⇒(1−α1L−⋯−αpLp)yt=α0+(1+β1L+⋯+βqLq)εt\\begin{aligned} &amp; y_t=\\alpha_0+\\sum_{i=1}^p \\alpha_i y_{t-i}+\\varepsilon_t+\\sum_{i=1}^q \\beta_i \\varepsilon_{t-i} \\\\ &amp; \\Rightarrow y_t=\\alpha_0+\\sum_{i=1}^p \\alpha_i L^i y_t+\\varepsilon_t+\\sum_{i=1}^q \\beta_i L^i \\varepsilon_t \\\\ &amp; \\Rightarrow\\left(1-\\sum_{i=1}^p \\alpha_i L^i\\right) y_t=\\alpha_0+\\left(1+\\sum_{i=1}^q \\beta_i L^i\\right) \\varepsilon_t \\\\ &amp; \\Rightarrow\\left(1-\\alpha_1 L-\\cdots-\\alpha_p L^p\\right) y_t=\\alpha_0+\\left(1+\\beta_1 L+\\cdots+\\beta_q L^q\\right) \\varepsilon_t \\\\ &amp; \\end{aligned} ​yt​=α0​+i=1∑p​αi​yt−i​+εt​+i=1∑q​βi​εt−i​⇒yt​=α0​+i=1∑p​αi​Liyt​+εt​+i=1∑q​βi​Liεt​⇒(1−i=1∑p​αi​Li)yt​=α0​+(1+i=1∑q​βi​Li)εt​⇒(1−α1​L−⋯−αp​Lp)yt​=α0​+(1+β1​L+⋯+βq​Lq)εt​​ 运用差分将不平稳数据变成平稳数据 一阶差分： Δyt=yt−yt−1=(1−L)yt\\Delta y_t=y_t-y_{t-1}=(1-L) y_t Δyt​=yt​−yt−1​=(1−L)yt​ 二阶差分: Δ2yt=Δ(Δyt)=Δ(yt−yt−1)=(yt−yt−1)−(yt−1−yt−2)=yt−2yt−1+yt−2=(1−2L+L2)yt=(1−L)2yt\\begin{aligned} \\Delta^2 y_t &amp; =\\Delta\\left(\\Delta y_t\\right)=\\Delta\\left(y_t-y_{t-1}\\right) \\\\ &amp; =\\left(y_t-y_{t-1}\\right)-\\left(y_{t-1}-y_{t-2}\\right) \\\\ &amp; =y_t-2 y_{t-1}+y_{t-2} \\\\ &amp; =\\left(1-2 L+L^2\\right) y_t \\\\ &amp; =(1-L)^2 y_t \\end{aligned} Δ2yt​​=Δ(Δyt​)=Δ(yt​−yt−1​)=(yt​−yt−1​)−(yt−1​−yt−2​)=yt​−2yt−1​+yt−2​=(1−2L+L2)yt​=(1−L)2yt​​ ddd 阶差分: Δdyt=(1−L)dyt\\Delta^d y_t=(1-L)^d y_t Δdyt​=(1−L)dyt​ 季节差分 ( m(~ m( m 为周期 ))) : Δyt−Δyt−m=(yt−yt−1)−(yt−m−yt−m−1)=(1−L−Lm+Lm+1)yt=(1−L)(1−Lm)yt\\begin{aligned} \\Delta y_t-\\Delta y_{t-m} &amp; =\\left(y_t-y_{t-1}\\right)-\\left(y_{t-m}-y_{t-m-1}\\right) \\\\ &amp; =\\left(1-L-L^m+L^{m+1}\\right) y_t \\\\ &amp; =(1-L)\\left(1-L^m\\right) y_t \\end{aligned} Δyt​−Δyt−m​​=(yt​−yt−1​)−(yt−m​−yt−m−1​)=(1−L−Lm+Lm+1)yt​=(1−L)(1−Lm)yt​​ 应用 思考步骤（不写在论文里） 1. 处理缺失值 生成时间变量并画出时间序列图 2. 数据是否为季度数据/月份数据（至少有两年）如果是 要看是否存在季节性波动 3. 根据时间序列图判断是否为平稳序列（数据围绕均值上下波动且无趋势和季节性） 4. SPSS：分析——时间序列预测——创建传统模型 5. 如果是ARIMA(p,0,q)，可以画出时间序列样本ACF和PACF图形进行分析，如果结果与季节性相关，可以考虑使用时间序列分解 SPSS时间序列建模器 变量:选择方法专家建模器——条件里面离群值全部勾选上（为了处理异常值） 白噪声残差检验: Q检验得到的p值大于0.05，说明无法拒绝原假设，即为白噪声(也可以用ACF与PACF图形说明)","link":"/2023/01/26/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/"},{"title":"数学建模笔记-聚类模型","text":"分类已知类别，聚类未知类别。 概念 聚类，就是将样本划分为由类似的对象组成的多个类的过程。 聚类后，我们可以更加准确的在每个类中单独使用统计模型进行估计、分析或预测；也可以探究不同类之间的相关性和主要差异。 K-means 指定需要划分的簇[cù]的个数K值（类的个数）; 随机地选择K个数据对象作为初始的聚类中心（不一定要是我们的样本点） 计算其余的各个数据对象到这K个初始聚类中心的距离，把数据对象划归到距离它最近的那个中心所处在的簇类中; 调整新类并且重新计算出新类的中心; 循环步骤3和4，看中心是否收敛（不变），如果收敛或达到迭代次数则停止循环; 结束。 优点：简单、迅速、对处理大数据集高效率。 缺点：要求用户必须给出K、对初值敏感（最终聚类效果和一开始选择的聚类中心有很大的关系）、对于孤立点数据敏感。 改进：K-means++算法可以解决缺点2和3 K-means++ 只对K-menas里“初始化K个聚类中心”进行了优化： 随机选择一个样本作为第一个聚类中心； 计算每个样本与当前已有聚类中心的最短距离（即与最近一个聚类中心的距离），这个值越大，表示被选取作为聚类中心的概率较大；最后，用轮盘法（依据概率大小来进行抽选）选出下一个聚类中心； 重复步骤2，直到选出K个聚类中心。选出初始点后，就继续使用标准的K-means算法了。 基本原则：初始的聚类中心之间的相互距离要尽可能的远。 SPSS操作步骤 K-means（默认使用K-means++）: graph LR A[分析] --> B(分类) --> C(K-均值聚类) C--> D(放入变量) C--> E(写入K) C--> F(迭代:更改N) C--> G(保存:勾选聚类成员和与聚类中心的距离) C--> H(选项:勾选初始聚类中心和每个个案的聚类信息) 讨论 聚类的个数K值怎么定？ 答：分几类主要取决于个人的经验与感觉，通常的做法是多尝试几个K值，看分成几类的结果更好解释，更符合分析目的等。 数据的量纲不一致怎么办？ 答：如果数据的量纲不一样，那么算距离时就没有意义。例如：如果X1单位是米，X2单位是吨，用距离公式计算就会出现“米的平方”加上“吨的平方”再开平方，最后算出的东西没有数学意义，这就有问题了，需要计算标准值。 zi=xi−xˉσx(先减去均值再除以标准差)z_{i}=\\frac{x_{i}-\\bar{x}}{\\sigma_{x}}\\text{(先减去均值再除以标准差)} zi​=σx​xi​−xˉ​(先减去均值再除以标准差) SPSS操作： graph LR B(分析) --> C(描述统计) --> D(描述)-->E(勾选将标准化值另存为变量) 系统（层次）聚类 绝对值距离 (网格) 欧氏距离 (常用) SPSS操作： graph LR A[分析] --> B(分类) --> C(系统聚类) C--> D(放入变量) C--> E(图:勾选谱系图)-->E1(根据聚合系数确定要分几类并说明) C--> F(方法:一般保持默认就可以) C--> G(统计与保存:可以更改分几类) DBSCAN算法 基于密度的聚类方法 用的很少 总结 一般情况下还是用系统聚类 只有两个指标且作图发现很DBSCAN时再用DBSCAN聚类","link":"/2023/01/21/%E8%81%9A%E7%B1%BB/"}],"tags":[{"name":"simple words","slug":"simple-words","link":"/tags/simple-words/"},{"name":"other","slug":"other","link":"/tags/other/"},{"name":"acm","slug":"acm","link":"/tags/acm/"},{"name":"一周题解","slug":"一周题解","link":"/tags/%E4%B8%80%E5%91%A8%E9%A2%98%E8%A7%A3/"},{"name":"note","slug":"note","link":"/tags/note/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"数学建模","slug":"数学建模","link":"/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"categories":[]}