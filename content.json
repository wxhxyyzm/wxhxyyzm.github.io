{"pages":[{"title":"about","text":"目前是JUNer 大二在读20岁秃头女大学生 不稳定的废话机器 博客用来干嘛的上传博客用的 联系方式Emile：wxhxyyzm@163.com QQ: 2193318985 都联系不上的话 就有缘漂流瓶见","link":"/about/index.html"},{"title":"所有标签","text":"","link":"/tags/index.html"},{"title":"links","text":"","link":"/links/index.html"},{"title":"categories","text":"","link":"/archives/index.html"}],"posts":[{"title":"Hello World","text":"重生之我是拖拉机 想起来两月前要搭个博客放东西 结果算是被ddl催着完成的 行吧 那就多学多记 多练多写 多多思考 多多益善 hello-welcome-to-my-world","link":"/2022/09/04/hello-world/"},{"title":"康复训练1","text":"9.5-9.8 这周主要是复习一下..发现很多东西都不记得了orz递归、分治主要写了点板子题目 典型的逆序对 归并排序代码改的12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int a[500005],b[500005];long long n,cnt;void add(int l,int r){ int mid=(l+r)/2; int p=l,q=mid+1; for(int i=l;i&lt;=r;i++) { if((q&gt;r)||(p&lt;=mid&amp;&amp;a[p]&lt;=a[q])) b[i]=a[p++]; else { cnt+=mid-p+1;//多这一行代码 b[i]=a[q++]; } } for(int i=l;i&lt;=r;i++) a[i]=b[i];}void merg(int l,int r){ if(l==r) return; int mid=(l+r)/2; merg(l,mid); merg(mid+1,r); add(l,r);}int main(){ cin&gt;&gt;n; for(int i=0;i&lt;n;i++) { cin&gt;&gt;a[i]; } merg(0,n-1); cout&lt;&lt;cnt&lt;&lt;endl; } 其实好像感觉之前也写过..sort过的 记一个快读板子（卡了好几次在这）1234567891011121314inline int read(){ int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9'){ if (ch == '-') f = -1; ch = getchar(); } while(ch &gt;= '0' &amp;&amp; ch &lt;= '9'){ x = (x&lt;&lt;1) + (x&lt;&lt;3) + (ch^48); ch = getchar(); } return x * f;} 兔子的逆序对大量读入需要快读板子 因为反转操作实际是将逆序对变成正序对 正序对变成逆序对 因为每交换一次就改变一次逆序对对数的奇偶性 所以只关注交换的次数就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;iostream&gt;#define int long longusing namespace std;const int N=100005;int a[N],b[N];long long n,cnt,cnt1,cnt2,t,f;inline int read(){ char c=getchar();int f=1; int x=0; while (c&lt;'0'||c&gt;'9') { if (c=='-') f=-1; c=getchar(); } while (c&gt;='0'&amp;&amp;c&lt;='9') { x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48); c=getchar(); } return x*f;}void add(int l,int r){ int mid=(l+r)/2; int p=l,q=mid+1; for(int i=l;i&lt;=r;i++) { if((q&gt;r)||(p&lt;=mid&amp;&amp;a[p]&lt;=a[q])) b[i]=a[p++]; else { cnt+=mid-p+1; b[i]=a[q++]; } } for(int i=l;i&lt;=r;i++) a[i]=b[i];}void merg(int l,int r){ if(l==r) return; int mid=(l+r)/2; merg(l,mid); merg(mid+1,r); add(l,r);}signed main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { a[i]=read(); } scanf(&quot;%lld&quot;,&amp;t); merg(1,n); if(cnt%2) f=1; else f=0; while(t--) { int a,b; scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b); int d=(b-a)*(b-a+1)/2; if(d%2) { f^=1; } if(f) printf(&quot;dislike\\n&quot;); else printf(&quot;like\\n&quot;); } } 快排板子 求第k大的数字1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int a[100];int n;void quick_sort(int l,int r){ int mid=(l+r)/2; int i=l,j=r; int x=a[mid];//store it while(a[i]&lt;x) i++; while(a[j]&gt;x) j--; while(i&lt;=j) { swap(a[i],a[j]); i++;j--; } if(l&lt;j) quick_sort(l,j);//如果是求第k大的数 改个这里 抛弃另一半 if(i&lt;r) quick_sort(i,r);}int main(){ cin&gt;&gt;n; for(int i=0;i&lt;n;i++) { cin&gt;&gt;a[i]; } quick_sort(0,n-1); for(int i=0;i&lt;n;i++) { cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; }} 一些递归的水题更相减损术实际上就是欧拉公式 遥远的数论记忆、、、 gcd(a,b)=gcd(a,a%b)/gcd(a,a-b) 证明很简单 12345int gcd(int a,int b){ if(b==0) return a; return gcd(b,a%b);} 汉诺塔问题嗯…感觉也是个规律问题 求解的时候牵涉了一点点高中数列的求通项 由A-&gt;C: (1)以C盘为中介，从A杆将1至n-1号盘移至B杆； (2)将A杆中剩下的第n号盘移至C杆； (3)以A杆为中介；从B杆将1至n-1号盘移至C杆。 f(n)=2*f(n-1)+1; 12345678void hanoi(int n, char a, char b, char c) { if (n == 0) return; hanoi(n - 1, a, c, b);//将n-1个盘子由A经过C移动到B printf (&quot;step %d: move %d from %c-&gt;%c\\n&quot;, cnt++, n, a, c); hanoi(n - 1, b, a, c);//剩下的n-1盘子，由B经过A移动到C} 有的题目会有一些附加条件 要自己重新算一下 感觉主要是求通项的问题 写代码直接写结论就可以了 other还有一些很简单的递归就不写了 一直觉得递归很难理解、、、说是将递归当成一把钥匙开一把锁然后一直到最里面那把钥匙（） 主要是思想问题 很需要理解（笨人落泪） 补了几道cf我有罪 我没及时补题 想起来有一些比赛的时候没写出来的C Color the Picture一个贪心问题 就是要保证颜色一定能涂相连的两行/两行以上 不能出现只有一行剩下的情况 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int t,n,m,k;int a[100005];bool solve(int m,int n,int k){ int ans=0; for(int i=0;i&lt;k;i++) { if(a[i]/n&gt;=2) { if((m-(ans+a[i]/n))==1) { if(a[i]/n&gt;2) ans+=(a[i]/n-1); } else ans+=a[i]/n; } } if(ans&gt;=m) return true; return false;}signed main(){ cin&gt;&gt;t; while(t--) { cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=0;i&lt;k;i++) { cin&gt;&gt;a[i]; } sort(a,a+k); if(solve(n,m,k)||solve(m,n,k)) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; }}l; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; }} o 还wa了一发在long long上 Doremy’s IQ觉得逆向思维的话更好理解 也更好写代码一些 也是贪心 就尽量让使q变小的排在后面 逆序遍历 从0开始 后面的都要 直到q等于题目给的q 不满足条件的就不要了 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#define int long longusing namespace std;const int N=100005;int t,n,q;int a[N];int b[N];signed main(){ cin&gt;&gt;t; while(t--) { cin&gt;&gt;n&gt;&gt;q; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; int cnt=0; for(int i=n-1;i&gt;=0;i--) { if(cnt&lt;q) { if(a[i]&gt;cnt) { cnt++; } b[i]=1; } else { if(q&gt;=a[i]) b[i]=1; else b[i]=0; } } for(int i=0;i&lt;n;i++) cout&lt;&lt;b[i]; cout&lt;&lt;endl; }} Digital Logarithm这题比赛的时候debug半小时、、无语住了 代码基本功太差了、、 思路大概就是先去重 然后求位数 再统计一下各个位数 然后求差值 去重不会写 sls教的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;using namespace std;int t,x,n;const int N=200005;int a[N],b[N];int qws(int x){ int cnt=0; while(x) { x=x/10; cnt++; } return cnt;}void qc(){ int i=1;int j=1; while(i&lt;=n&amp;&amp;j&lt;=n) { if(a[i]&lt;b[j]) i++; else if(a[i]&gt;b[j]) j++; else { a[i]=0;b[j]=0;i++;j++; } }}signed main(){ cin&gt;&gt;t; while(t--) { cin&gt;&gt;n; int b1[15],b2[15];memset(b1,0,sizeof(b1));memset(b2,0,sizeof(b2)); int ccnt=0; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;=n;i++) cin&gt;&gt;b[i]; sort(a+1,a+n+1); sort(b+1,b+1+n); qc(); for(int i=1;i&lt;=n;i++) { if(a[i]&gt;9) { a[i]=qws(a[i]); ccnt++; } if(b[i]&gt;9) { b[i]=qws(b[i]); ccnt++; } } for(int i=1;i&lt;=n;i++) { b1[a[i]]++; b2[b[i]]++; } for(int i=2;i&lt;=9;i++) { ccnt+=abs(b1[i]-b2[i]); } cout&lt;&lt;ccnt&lt;&lt;endl; }} 写在最后嗯…效率比预计得低很多 下周继续做递归分治 板子写的还不够熟T T","link":"/2022/09/10/%E5%BA%B7%E5%A4%8D%E8%AE%AD%E7%BB%831/"},{"title":"week2-3","text":"因为一些原因上周落了一些orz 这两周继续递归分治+一点二分顺便改进了一下写博客的方法[NOIP2001]求先序排列题意：已知二叉树的中序和后序排列，求它的先序排列； 求解：二叉树的基本题，首先概念：先序：根-左-右；中序：左-根-右；后序：左-右-根 通过后序的最后一个位置确定根 通过这个根 在中序中找到根的位置 左边是左子树 右边是右子树；然后用递归的方式 事实上中序和后序表达的是同一颗子树 所以可以用长度求出第四个端点； 1234deal(l1,r1,l2,r2);//1中序 2后序deal(l1,pos-1,l2,l2+pos-1-l1);//pos是在中序里找到的根的位置deal(pos+1,r1,l2-l1+pos,r2-1); [NOIP2004]FBI树题意：全0：B；全1：I；有1有0：F；给定一个长度为2的n次方的“01”串，求其FBI树的后序遍历（左右根） 求解：递归做法 多点判断+后序输出 按左右根的顺序 如果到叶节点就直接判断输出 华华教月月做数学题意：就是求 A^B mod P 求解：基础的快排板子 有一个大数的问题 （可以用python解决 __int128也可以过）或者可以将快速幂中的乘法拆成加法求余 快速幂的思想就是倍增思想 把幂拆掉求余 贴个板子 1234567891011ll quickm(ll a,ll b,ll p){ tmp=a,ans=1; while(b) { if(b&amp;1) ans=ans*tmp%p; tmp=tmp*tmp%p; b&gt;&gt;=1; } return ans;} P2880 [USACO07JAN] Balanced Lineup G题意：给个为n的数列 给q次询问 每次问a,b之间最大值和最小值之间的差值 求解：线段树 写两棵树 一棵树存最大的 一棵树存最小的 然后相减一下 P1115 最大子段和题意：如题 求解：两种想法 一是分治：①求左边的最大字段和②求右边的最大字段和③求左边那段包含最右边点的最大字段和+右边那段包含最左边点的最大字段和 三者取最大 二是贪心：求前缀和 一旦前缀和小于0 就清零 写二的时候卡了一次 没有把第一个数存下来当sum 感觉这个贪心想的没有那么直观（我太菜了） P1257 平面上的最接近点对题意：如题 求解：还是分治：取个中轴线 ①求左边平面最接近点 ②求右边平面最接近点 ③分在两边平面的点 但可以用前两个求出来的最小值来约束y轴范围 排个序 这样就是从有限的点中求出最短距离； P1613 跑路题意：给n个点 m条边 一条边代表一千米 每秒可以跑2^k（k是任意自然数）千米 要求从1到n的最小时间 求解：这题感觉还是很有意思的 因为n&lt;=50 所以可以很暴力 用倍增的思想预处理一下数据 i到t再到j 如果i到j有2^k-1千米的路 j到t又有2^k-1千米的路 那么i到j就有2^k的路 可以一秒到达 把dis改为1最后用Floyd法求最短路 疯狂写循环（ 123456789101112131415161718192021void bz(){ for(int k=1;k&lt;=64;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int t=1;t&lt;=n;t++) { if(b[i][j][k-1]&amp;&amp;b[j][t][k-1]) { b[i][t][k]=true; dis[i][t]=1; } }}void floyd(){ for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); } P2415 集合求和题意：输入一个集合的所有元素 求所有子集的元素之和 求解：数学问题 首先会有2^n个子集 一半有这个数 另一半没有这个数 所以总共出现了2^（n-1）次 算一下就可以了 P3197 [HNOI2008]越狱题意：有n个屋子 m种宗教 相邻的屋子里的人如果是同一种宗教就会越狱 问有多少种可能 答案对100003 取模 求解：还是数学问题 公式是m^n-(m-1)^(n-1) 还是一个快速幂的题目 但是！wa了好几次 后来发现是最后因为是一个减法 有可能存在负数的情况 所以要+p再%p P2249 【深基13.例1】查找题意：二分查找 求解：用的lower_bound（第一个≥x的位置）和upper_bound（第一个＞x的位置）自带函数做的 自己写的话很容易出现边界和卡在循环里面的问题 每次写的时候还是要注意一下 P1102 A-B 数对题意：给N个数和C 求数列中满足A-B的数对个数 求解：写了个双循环然后用二分查找的函数直接写的 十分暴力简单的做法（ P1873 [COCI 2011/2012 #5] EKO / 砍树题意：N个木材 需要总长度M 定一个H使得能够砍到M米木材 为了怕浪费 求最小的H 求解：二分的运用 就写个check函数判断一下 如果能砍到M就改r 否则就改l P1678 烦恼的高考志愿题意：给出m个分数线 以及n个同学的估分 要求帮每个估分找出最合理的分数线 两者相差为不满意度 求不满意度最小值 求解：还是用的二分函数 给分数线排个序 用每个人的估分去找相近的分数线 然后前后都算一下 取一个min值 P2440 木材加工题意：把n根原木切割成 k 段长度均为 l 的小段木头 求l的最大值 求解：依然是二分的运用 写个check能切成k段就缩小一点l 反之放大 写起来很简单 总结进度还是挺慢 其实很多东西都相当于复习了 但是！完全没有印象…….. 所以改进了一下写题解的方式 看起来轻松些 便于自己复习 也不贴代码了 有空还可以自己再码一遍 要不然学过和没学一样orz 做的题都不算难 重建一下信心（）下周继续二分","link":"/2022/09/20/week3/"},{"title":"week5","text":"达成三个单周坚持写博客成就（555因为双周都没写orz） 进度依然慢…cf-Card Game题意：博弈问题 给个n即n张牌（由1到n）每个人分n/2张 从Alex开始出牌 后手一定要比先手出的牌大 接u着Boris出 到谁出不了了就输了 求Alex赢、Boris赢和平局的分牌方式 求解：从最大的四张开始分 A先手 所以A赢就有两种 要么最大的在A 如果最大在B 那剩下的n-1和n-2必须在A n-3在A A赢 n-3不在 这四张牌平局 因而递归下去 由此可得f[n]=C(n/2-1,n-1)+C(2/n-3,n-4)+f[n-4]的递归公式 四张四张求解即可 写这题的时候思维很凝固的感觉 感觉还是要从NP开始想 觉得我的思考很没有条理性 还要注意一点 有取模和减法一起出现的时候 为了防止出现负数 要+MOD再%MOD 贴一个求组合数的板子(n比较小的情况) 123456789101112131415void C(){ c[0][0]=1; for(int i=0;i&lt;=70;i++) { for(int j=0;j&lt;=70;j++) { if(j==0||j==i) c[i][j]=1; else { c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod; } } }} cf-Reset K Edges题意：给n个结点 以及他们的深度（1的深度是0）还可以进行k次操作 一次操作：删掉一条边 将剩下的连到1的下面去 问最多经过k操作后的最小的树的深度 求解：二分+贪心 从下向上遍历 到了高度为mid-1的那一层 如果是根节点 那么不用动 但如果不是 就把这棵子树接到1上 记录进行的操作次数与k对比 注意为了做到无后效性 要从下向上遍历 cf-1250J题意：有一群人 要站队 给个n 给个k n表示有n个不同的身高 (全部的身高从1-n) k表示要站几排 然后会依次给出每个身高下有多少个人 站队要求：一排里面两人身高最多相差1cm 求最后的方针里最多有多少个人 求解：求最大最小值的问题自然想到二分 这题是一个二分+一点贪心 总体框架没什么问题 在站队的贪心上出了点问题 应该是从小到大依次看这个身高能组成多少队列 然后从后一个身高里取一部分人恰好凑成新的一列 这样的贪心才是最优的（搞不懂我怎么想的 就不写错误思路了） arc146-B Plus and AND题意：n m k n个数 能给他们加m个1 问选k个数 进行与运算(e.g 011 AND 101=001)的最大值 求解：位运算的问题 从高位到低位贪心 如果m能够使得 k个数字这一位都为1 就消耗掉 如果不能 就继续向下贪心（因为只要有1个0 与运算后就都为0了）从31跑到0 一位一位判断 其实感觉这题思路倒是很好理解 就是代码好难写哦(我太菜了) 贴个代码吧 12345678910111213141516171819202122232425for(int i=31;i&gt;=0;i--)//从高位到低位贪心 { for(int j=0;j&lt;n;j++) { b[j]=c[j]; if((a[j]&gt;&gt;i)&amp;1) continue; else b[j]+=(1ll&lt;&lt;i)-(a[j]%(1ll&lt;&lt;i)); } sort(b,b+n); ll sum=0; for(int j=0;j&lt;k;j++) sum+=b[j]; if(sum&lt;=m) { ans|=(1ll&lt;&lt;i); for(int j=0;j&lt;n;j++) { if(a[j]&gt;&gt;i&amp;1) continue; else { c[j]+=(1ll&lt;&lt;i)-(a[j]%(1ll&lt;&lt;i)); a[j]=1ll&lt;&lt;i; } } } } zls说位运算就要么从高位到低位想 要么从低位到高位想 牛客-跳石头题意：给L N M 分别表示起点到终点的距离 起点和终点之间的岩石数 以及组委会至多移走的岩石数 求最短跳跃距离的最大值 求解：经典二分 通过mid看需要移走几块石头 贴个check代码 12345678910111213int cnt=0;int last=0;for(int j=0;j&lt;=n;j++){ if(x[j]-last&lt;w) cnt++; else { last=x[j]; }}if (cnt&lt;=m) return true;else return false; 牛客-数字组合题意：给四个数组 问每个数组取一个数字 四个数字和为0 有多少种取法 求解：一个时间复杂度上的优化 先两两加一下组成两个新的数组 然后二分查找一下 牛客-[CQOI2010]扑克牌题意：有n种牌 每种牌张数不一样 还有m张joker n张不同的牌可以凑成一副牌 但是每副牌里不能出现相同的牌（即joker最多可以代替一张普通牌）问最多多少副牌 求解：还是二分 判断要补多少张joker（注意不能超过mid） 注意开long long 1234567int s=0;for(int i=0;i&lt;n;i++){ s+=max(mid-a[i],(long long)0); } if(m&gt;=s&amp;&amp;mid&gt;=s) return true; else return false;false; 牛客-K-th Number题意：A数组有n个数 给了个k 将所有大于等于k的区间中的第k大的数放入B数组中 然后问B中第m大的数是哪个 求解：这题很难想到是二分（如果没出现在题单里我肯定想不到）找出所有区间中包含大于等于k个大于等于mid的区间的数量 check函数不太好写 看到很牛的代码 用数组s去记录从1开始大于等于mid的数字数量 然后从第k个数开始遍历 如果（l-i）区间满足条件 那么l之前的更长的区间必定满足条件 所以sum+=l即是目前为止满足条件的区间数 整个思维的转换很有意思 123456789101112int sum=0;for(int i=1;i&lt;=n;i++){ if(a[i]&gt;=mid) s[i]=s[i-1]+1; else s[i]=s[i-1];}int l=0;for(int i=k;i&lt;=n;i++){ while(s[i]-s[l]&gt;=k) l++; sum+=l;} 总结先写这么多 感觉最近整个思维出现很紊乱的状态 下周开始复习一些基础的东西+过一遍贪心","link":"/2022/10/03/week5/"},{"title":"Alicenofear","text":"A sad mein a strang world 更一些other words 最近博客很久没有更新了 断断续续也有写题和补题 但是感觉没有及时整理和复盘 专业课的东西学的也有点吃力 旧的不会新的又来 额外的还有前端的一些东西要看 计算机好难学哦 acm好难打啊 我的大脑就像那种老旧配置低下的电子设备 时不时需要停下来什么都不干 冷却一段时间 但是赶路要紧 不能停下 整个人就好像被拖着走 发现自己写题的状态忽好忽坏 正式比赛的时候也会由于一点点状态的偏移 导致整场都很不OK 自己想了想 就是还不够熟练 太菜了吧 菜是原罪 写着Alice no fear 却找不到任何拯救自己的方式","link":"/2022/10/29/Alicenofear/"}],"tags":[{"name":"simple words","slug":"simple-words","link":"/tags/simple-words/"},{"name":"other","slug":"other","link":"/tags/other/"},{"name":"acm","slug":"acm","link":"/tags/acm/"},{"name":"一周题解","slug":"一周题解","link":"/tags/%E4%B8%80%E5%91%A8%E9%A2%98%E8%A7%A3/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"}],"categories":[]}