{"pages":[{"title":"about","text":"目前是JUNer 大二在读20岁秃头女大学生 不稳定的废话机器 博客用来干嘛的上传博客用的 联系方式Emile：wxhxyyzm@163.com QQ: 2193318985 都联系不上的话 就有缘漂流瓶见","link":"/about/index.html"},{"title":"所有标签","text":"","link":"/tags/index.html"},{"title":"links","text":"","link":"/links/index.html"},{"title":"categories","text":"","link":"/archives/index.html"}],"posts":[{"title":"Hello World","text":"重生之我是拖拉机想起来两月前要搭个博客放东西 结果算是被ddl催着完成的 行吧 那就多学多记 多练多写 多多思考 多多益善 hello-welcome-to-my-world","link":"/2022/09/04/hello-world/"},{"title":"康复训练1","text":"9.5-9.8这周主要是复习一下..发现很多东西都不记得了orz递归、分治主要写了点板子题目 典型的逆序对 归并排序代码改的12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int a[500005],b[500005];long long n,cnt;void add(int l,int r){ int mid=(l+r)/2; int p=l,q=mid+1; for(int i=l;i&lt;=r;i++) { if((q&gt;r)||(p&lt;=mid&amp;&amp;a[p]&lt;=a[q])) b[i]=a[p++]; else { cnt+=mid-p+1;//多这一行代码 b[i]=a[q++]; } } for(int i=l;i&lt;=r;i++) a[i]=b[i];}void merg(int l,int r){ if(l==r) return; int mid=(l+r)/2; merg(l,mid); merg(mid+1,r); add(l,r);}int main(){ cin&gt;&gt;n; for(int i=0;i&lt;n;i++) { cin&gt;&gt;a[i]; } merg(0,n-1); cout&lt;&lt;cnt&lt;&lt;endl; } 其实好像感觉之前也写过..sort过的 记一个快读板子（卡了好几次在这）1234567891011121314inline int read(){ int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9'){ if (ch == '-') f = -1; ch = getchar(); } while(ch &gt;= '0' &amp;&amp; ch &lt;= '9'){ x = (x&lt;&lt;1) + (x&lt;&lt;3) + (ch^48); ch = getchar(); } return x * f;} 兔子的逆序对大量读入需要快读板子 因为反转操作实际是将逆序对变成正序对 正序对变成逆序对 因为每交换一次就改变一次逆序对对数的奇偶性 所以只关注交换的次数就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;iostream&gt;#define int long longusing namespace std;const int N=100005;int a[N],b[N];long long n,cnt,cnt1,cnt2,t,f;inline int read(){ char c=getchar();int f=1; int x=0; while (c&lt;'0'||c&gt;'9') { if (c=='-') f=-1; c=getchar(); } while (c&gt;='0'&amp;&amp;c&lt;='9') { x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48); c=getchar(); } return x*f;}void add(int l,int r){ int mid=(l+r)/2; int p=l,q=mid+1; for(int i=l;i&lt;=r;i++) { if((q&gt;r)||(p&lt;=mid&amp;&amp;a[p]&lt;=a[q])) b[i]=a[p++]; else { cnt+=mid-p+1; b[i]=a[q++]; } } for(int i=l;i&lt;=r;i++) a[i]=b[i];}void merg(int l,int r){ if(l==r) return; int mid=(l+r)/2; merg(l,mid); merg(mid+1,r); add(l,r);}signed main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { a[i]=read(); } scanf(&quot;%lld&quot;,&amp;t); merg(1,n); if(cnt%2) f=1; else f=0; while(t--) { int a,b; scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b); int d=(b-a)*(b-a+1)/2; if(d%2) { f^=1; } if(f) printf(&quot;dislike\\n&quot;); else printf(&quot;like\\n&quot;); } } 快排板子 求第k大的数字1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int a[100];int n;void quick_sort(int l,int r){ int mid=(l+r)/2; int i=l,j=r; int x=a[mid];//store it while(a[i]&lt;x) i++; while(a[j]&gt;x) j--; while(i&lt;=j) { swap(a[i],a[j]); i++;j--; } if(l&lt;j) quick_sort(l,j);//如果是求第k大的数 改个这里 抛弃另一半 if(i&lt;r) quick_sort(i,r);}int main(){ cin&gt;&gt;n; for(int i=0;i&lt;n;i++) { cin&gt;&gt;a[i]; } quick_sort(0,n-1); for(int i=0;i&lt;n;i++) { cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; }} 一些递归的水题更相减损术实际上就是欧拉公式 遥远的数论记忆、、、 gcd(a,b)=gcd(a,a%b)/gcd(a,a-b) 证明很简单 12345int gcd(int a,int b){ if(b==0) return a; return gcd(b,a%b);} 汉诺塔问题嗯…感觉也是个规律问题 求解的时候牵涉了一点点高中数列的求通项 由A-&gt;C: (1)以C盘为中介，从A杆将1至n-1号盘移至B杆； (2)将A杆中剩下的第n号盘移至C杆； (3)以A杆为中介；从B杆将1至n-1号盘移至C杆。 f(n)=2*f(n-1)+1; 12345678void hanoi(int n, char a, char b, char c) { if (n == 0) return; hanoi(n - 1, a, c, b);//将n-1个盘子由A经过C移动到B printf (&quot;step %d: move %d from %c-&gt;%c\\n&quot;, cnt++, n, a, c); hanoi(n - 1, b, a, c);//剩下的n-1盘子，由B经过A移动到C} 有的题目会有一些附加条件 要自己重新算一下 感觉主要是求通项的问题 写代码直接写结论就可以了 other还有一些很简单的递归就不写了 一直觉得递归很难理解、、、说是将递归当成一把钥匙开一把锁然后一直到最里面那把钥匙（） 主要是思想问题 很需要理解（笨人落泪） 补了几道cf我有罪 我没及时补题 想起来有一些比赛的时候没写出来的C Color the Picture一个贪心问题 就是要保证颜色一定能涂相连的两行/两行以上 不能出现只有一行剩下的情况 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int t,n,m,k;int a[100005];bool solve(int m,int n,int k){ int ans=0; for(int i=0;i&lt;k;i++) { if(a[i]/n&gt;=2) { if((m-(ans+a[i]/n))==1) { if(a[i]/n&gt;2) ans+=(a[i]/n-1); } else ans+=a[i]/n; } } if(ans&gt;=m) return true; return false;}signed main(){ cin&gt;&gt;t; while(t--) { cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=0;i&lt;k;i++) { cin&gt;&gt;a[i]; } sort(a,a+k); if(solve(n,m,k)||solve(m,n,k)) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; }}l; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; }} o 还wa了一发在long long上 Doremy’s IQ觉得逆向思维的话更好理解 也更好写代码一些 也是贪心 就尽量让使q变小的排在后面 逆序遍历 从0开始 后面的都要 直到q等于题目给的q 不满足条件的就不要了 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#define int long longusing namespace std;const int N=100005;int t,n,q;int a[N];int b[N];signed main(){ cin&gt;&gt;t; while(t--) { cin&gt;&gt;n&gt;&gt;q; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; int cnt=0; for(int i=n-1;i&gt;=0;i--) { if(cnt&lt;q) { if(a[i]&gt;cnt) { cnt++; } b[i]=1; } else { if(q&gt;=a[i]) b[i]=1; else b[i]=0; } } for(int i=0;i&lt;n;i++) cout&lt;&lt;b[i]; cout&lt;&lt;endl; }} Digital Logarithm这题比赛的时候debug半小时、、无语住了 代码基本功太差了、、 思路大概就是先去重 然后求位数 再统计一下各个位数 然后求差值 去重不会写 sls教的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;string.h&gt;#include&lt;cmath&gt;using namespace std;int t,x,n;const int N=200005;int a[N],b[N];int qws(int x){ int cnt=0; while(x) { x=x/10; cnt++; } return cnt;}void qc(){ int i=1;int j=1; while(i&lt;=n&amp;&amp;j&lt;=n) { if(a[i]&lt;b[j]) i++; else if(a[i]&gt;b[j]) j++; else { a[i]=0;b[j]=0;i++;j++; } }}signed main(){ cin&gt;&gt;t; while(t--) { cin&gt;&gt;n; int b1[15],b2[15];memset(b1,0,sizeof(b1));memset(b2,0,sizeof(b2)); int ccnt=0; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;=n;i++) cin&gt;&gt;b[i]; sort(a+1,a+n+1); sort(b+1,b+1+n); qc(); for(int i=1;i&lt;=n;i++) { if(a[i]&gt;9) { a[i]=qws(a[i]); ccnt++; } if(b[i]&gt;9) { b[i]=qws(b[i]); ccnt++; } } for(int i=1;i&lt;=n;i++) { b1[a[i]]++; b2[b[i]]++; } for(int i=2;i&lt;=9;i++) { ccnt+=abs(b1[i]-b2[i]); } cout&lt;&lt;ccnt&lt;&lt;endl; }} 写在最后嗯…效率比预计得低很多 下周继续做递归分治 板子写的还不够熟T T","link":"/2022/09/10/%E5%BA%B7%E5%A4%8D%E8%AE%AD%E7%BB%831/"}],"tags":[{"name":"simple words","slug":"simple-words","link":"/tags/simple-words/"},{"name":"other","slug":"other","link":"/tags/other/"},{"name":"acm","slug":"acm","link":"/tags/acm/"},{"name":"一周题解","slug":"一周题解","link":"/tags/%E4%B8%80%E5%91%A8%E9%A2%98%E8%A7%A3/"}],"categories":[]}